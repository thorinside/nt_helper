---
phase: 01-type-system-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/ui/midi_listener/midi_listener_state.dart
  - lib/ui/midi_listener/midi_listener_cubit.freezed.dart
  - lib/ui/midi_listener/midi_detector_widget.dart
  - lib/ui/widgets/packed_mapping_data_editor.dart
  - test/ui/midi_listener/midi_listener_state_test.dart
autonomous: true

must_haves:
  truths:
    - "MidiEventType enum has 5 variants: cc, noteOn, noteOff, cc14BitLowFirst, cc14BitHighFirst"
    - "Existing 7-bit CC detection code compiles and works unchanged"
    - "Existing note detection code compiles and works unchanged"
    - "MidiListenerState.data can store 14-bit event types in lastDetectedType"
    - "All switch expressions on MidiEventType are exhaustive (handle all 5 variants)"
    - "Freezed generated code is up to date and compiles without errors"
    - "flutter analyze reports zero warnings"
  artifacts:
    - path: "lib/ui/midi_listener/midi_listener_state.dart"
      provides: "MidiEventType enum with 14-bit variants"
      contains: "cc14BitLowFirst"
    - path: "lib/ui/midi_listener/midi_listener_cubit.freezed.dart"
      provides: "Regenerated Freezed code for MidiListenerState"
    - path: "lib/ui/midi_listener/midi_detector_widget.dart"
      provides: "Pattern matching updated for 5 MidiEventType variants"
      contains: "cc14BitLowFirst"
    - path: "lib/ui/widgets/packed_mapping_data_editor.dart"
      provides: "14-bit type handling in onMidiEventFound callback"
      contains: "cc14BitLowFirst"
    - path: "test/ui/midi_listener/midi_listener_state_test.dart"
      provides: "Tests verifying state model with all MidiEventType variants"
  key_links:
    - from: "lib/ui/midi_listener/midi_listener_state.dart"
      to: "lib/ui/midi_listener/midi_detector_widget.dart"
      via: "switch expression on MidiEventType"
      pattern: "MidiEventType\\.cc14BitLowFirst"
    - from: "lib/ui/midi_listener/midi_listener_state.dart"
      to: "lib/ui/widgets/packed_mapping_data_editor.dart"
      via: "if/else on MidiEventType in onMidiEventFound"
      pattern: "MidiEventType\\.cc14BitLowFirst"
---

<objective>
Extend the MidiEventType enum with 14-bit variants and update all consumers to handle them, without breaking existing 7-bit CC and note detection.

Purpose: Lay the type system foundation that Phase 2 (detection logic) and Phase 3 (UI integration) will build upon. Without these types, 14-bit detection results have no way to flow through the system.

Output: Extended enum, updated pattern matching in 2 UI files, regenerated Freezed code, and unit tests proving the state model works with all variants.
</objective>

<execution_context>
@/Users/nealsanche/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nealsanche/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-type-system-foundation/01-RESEARCH.md

Key source files:
@lib/ui/midi_listener/midi_listener_state.dart
@lib/ui/midi_listener/midi_listener_cubit.dart
@lib/ui/midi_listener/midi_detector_widget.dart
@lib/ui/widgets/packed_mapping_data_editor.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend MidiEventType enum and update all pattern matching</name>
  <files>
    lib/ui/midi_listener/midi_listener_state.dart
    lib/ui/midi_listener/midi_detector_widget.dart
    lib/ui/widgets/packed_mapping_data_editor.dart
  </files>
  <action>
1. In `lib/ui/midi_listener/midi_listener_state.dart`, extend the `MidiEventType` enum:
   - Add `cc14BitLowFirst` variant after `noteOff` — means lower CC number (0-31) is MSB
   - Add `cc14BitHighFirst` variant after `cc14BitLowFirst` — means higher CC number (32-63) is MSB
   - Add doc comments on each variant explaining what it represents
   - Do NOT change MidiListenerState fields — existing `lastDetectedCc` will store the lower CC number for 14-bit, same as it stores the CC number for 7-bit

2. In `lib/ui/midi_listener/midi_detector_widget.dart`, update BOTH switch expressions on `MidiEventType` (lines ~107-111 and ~178-182):
   - Add cases for `MidiEventType.cc14BitLowFirst => ('14-bit CC', s.lastDetectedCc)` (or `lastDetectedCc` in the BlocConsumer)
   - Add cases for `MidiEventType.cc14BitHighFirst => ('14-bit CC', s.lastDetectedCc)` (or `lastDetectedCc` in the BlocConsumer)
   - Both 14-bit variants display the same label "14-bit CC" and use `lastDetectedCc` for the number

3. In `lib/ui/widgets/packed_mapping_data_editor.dart`, update the `onMidiEventFound` callback (around line 694-705):
   - After the existing note type check, add an else-if block:
     ```dart
     else if (type == MidiEventType.cc14BitLowFirst) {
       detectedMappingType = MidiMappingType.cc14BitLow;
     } else if (type == MidiEventType.cc14BitHighFirst) {
       detectedMappingType = MidiMappingType.cc14BitHigh;
     }
     ```
   - Place this BEFORE the final `_data = _data.copyWith(...)` call, after the note type check
   - The `number` parameter already maps correctly to `midiCC` for 14-bit (it will be the lower CC number 0-31)

4. In `lib/ui/midi_listener/midi_listener_cubit.dart`, update the threshold check (around line 169-172):
   - The existing threshold logic only applies to `MidiEventType.cc`. For 14-bit types, they should also NOT require threshold (Phase 2 will handle its own threshold before emitting these types).
   - BUT: In Phase 1, no code will ever emit `cc14BitLowFirst` or `cc14BitHighFirst` — the cubit only produces `cc`, `noteOn`, `noteOff` today. So the threshold logic does not need to change yet. Leave it as-is; Phase 2 will refactor the detection path entirely.

5. Run `flutter pub run build_runner build --delete-conflicting-outputs` to regenerate Freezed code.

6. Run `flutter analyze` to verify zero warnings.
  </action>
  <verify>
    - `flutter pub run build_runner build --delete-conflicting-outputs` completes without errors
    - `flutter analyze` reports zero warnings/errors
    - `MidiEventType.values.length == 5`
    - Both switch expressions in `midi_detector_widget.dart` have 5 cases (exhaustive)
    - `packed_mapping_data_editor.dart` handles `cc14BitLowFirst` and `cc14BitHighFirst`
  </verify>
  <done>
    MidiEventType enum has 5 variants. All pattern matching is exhaustive. Freezed code regenerated. flutter analyze passes with zero warnings.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write unit tests for state model with 14-bit types</name>
  <files>
    test/ui/midi_listener/midi_listener_state_test.dart
  </files>
  <action>
Create `test/ui/midi_listener/midi_listener_state_test.dart` with the following test cases:

1. **Test: MidiEventType has exactly 5 variants**
   - `expect(MidiEventType.values.length, 5)`
   - Verify all 5 names: cc, noteOn, noteOff, cc14BitLowFirst, cc14BitHighFirst

2. **Test: MidiListenerState.data accepts all MidiEventType variants**
   - Loop through `MidiEventType.values`
   - For each, create `MidiListenerState.data(lastDetectedType: type)`
   - Verify `state.lastDetectedType == type`

3. **Test: copyWith preserves 14-bit type (cc14BitLowFirst)**
   - Create state with `lastDetectedType: MidiEventType.cc14BitLowFirst`, `lastDetectedCc: 1`, `lastDetectedChannel: 0`
   - Call `copyWith(lastDetectedTime: DateTime.now())`
   - Verify `lastDetectedType`, `lastDetectedCc`, and `lastDetectedChannel` are preserved

4. **Test: copyWith preserves 14-bit type (cc14BitHighFirst)**
   - Same as above but with `cc14BitHighFirst`

5. **Test: initial state has null lastDetectedType**
   - Create `MidiListenerState.initial()`
   - Verify it is of type `Initial` (not `Data`)

6. **Test: 14-bit types are distinct from 7-bit cc type**
   - `expect(MidiEventType.cc14BitLowFirst, isNot(MidiEventType.cc))`
   - `expect(MidiEventType.cc14BitHighFirst, isNot(MidiEventType.cc))`
   - `expect(MidiEventType.cc14BitLowFirst, isNot(MidiEventType.cc14BitHighFirst))`

Import: `package:nt_helper/ui/midi_listener/midi_listener_cubit.dart` (which re-exports the state via `part`)
Use `flutter_test` package.
Follow existing test conventions: `group()` wrapping related tests, descriptive test names.
  </action>
  <verify>
    - `flutter test test/ui/midi_listener/midi_listener_state_test.dart` passes all tests
    - No skipped or failing tests
  </verify>
  <done>
    All 6 test cases pass. State model correctly handles all 5 MidiEventType variants including 14-bit types. copyWith preserves type information. Types are distinct.
  </done>
</task>

</tasks>

<verification>
1. `flutter analyze` — zero warnings/errors
2. `flutter test test/ui/midi_listener/midi_listener_state_test.dart` — all tests pass
3. `flutter test` — full test suite passes (no regressions)
4. Grep for `MidiEventType` in source files confirms all switch/if-else chains handle new variants
</verification>

<success_criteria>
- MidiEventType enum has exactly 5 variants: cc, noteOn, noteOff, cc14BitLowFirst, cc14BitHighFirst
- MidiListenerState.data can store any MidiEventType variant in lastDetectedType
- midi_detector_widget.dart switch expressions handle all 5 variants
- packed_mapping_data_editor.dart onMidiEventFound handles 14-bit types mapping to MidiMappingType.cc14BitLow/cc14BitHigh
- Freezed code regenerated and committed
- flutter analyze passes with zero warnings
- All new tests pass
- Full test suite passes (no regressions from existing tests)
</success_criteria>

<output>
After completion, create `.planning/phases/01-type-system-foundation/01-01-SUMMARY.md`
</output>
