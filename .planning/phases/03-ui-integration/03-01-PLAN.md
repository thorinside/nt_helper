---
phase: 03-ui-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/ui/midi_listener/midi_detector_widget.dart
  - test/ui/midi_listener/midi_detector_widget_test.dart
autonomous: true

must_haves:
  truths:
    - "14-bit detection status message is concise (4-5 words): '14-bit CC X Ch Y'"
    - "7-bit CC status message format unchanged"
    - "Note detection status message format unchanged"
    - "onMidiEventFound callback fires with correct 14-bit type"
    - "Mapping editor auto-configures cc14BitLow/cc14BitHigh from detection"
    - "flutter analyze passes with zero warnings"
  artifacts:
    - path: "lib/ui/midi_listener/midi_detector_widget.dart"
      provides: "Concise 14-bit status message format"
      contains: "14-bit CC"
    - path: "test/ui/midi_listener/midi_detector_widget_test.dart"
      provides: "Widget tests for 14-bit detection UI"
      min_lines: 50
  key_links:
    - from: "lib/ui/midi_listener/midi_detector_widget.dart"
      to: "MidiListenerCubit state"
      via: "BlocConsumer listener"
      pattern: "cc14BitLowFirst.*14-bit CC"
    - from: "lib/ui/midi_listener/midi_detector_widget.dart"
      to: "packed_mapping_data_editor.dart"
      via: "onMidiEventFound callback"
      pattern: "widget.onMidiEventFound"
---

<objective>
Update the MIDI detector status message to show concise 14-bit results and add widget tests verifying the complete 14-bit UI integration.

Purpose: Phase 1 already added 14-bit type handlers to the detector widget and mapping editor (UI-02, UI-03, UI-04 are done). The remaining work is UI-01: the status message still uses the verbose format ("Detected 14-bit CC 1 on channel 1" — 8 words) instead of the required concise format ("14-bit CC 1 Ch 1" — 5 words). Widget tests are needed to verify the complete integration.
Output: Updated status message format + new widget test file.
</objective>

<execution_context>
@/Users/nealsanche/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nealsanche/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-ui-integration/03-RESEARCH.md
@lib/ui/midi_listener/midi_detector_widget.dart
@lib/ui/midi_listener/midi_listener_state.dart
@lib/ui/midi_listener/midi_listener_cubit.dart
@lib/ui/widgets/packed_mapping_data_editor.dart
@test/ui/midi_listener/midi_listener_state_test.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update 14-bit status message format to concise 4-5 word style</name>
  <files>lib/ui/midi_listener/midi_detector_widget.dart</files>
  <action>
Update the status message generation for 14-bit CC types in TWO locations within `midi_detector_widget.dart`:

**Location 1 — initState replay (around line 116-117):**
Currently: `'Detected ${eventInfo.$1} $eventNumber on channel ${channel + 1}'`
This handles ALL event types with one format string. For 14-bit types, the result is "Detected 14-bit CC 1 on channel 1" (8 words — too long).

Change the status message generation AFTER the switch expression so that 14-bit types use a different format:
- For `cc14BitLowFirst` and `cc14BitHighFirst`: `'14-bit CC $eventNumber Ch ${channel + 1}'` (5 words)
- For `cc`, `noteOn`, `noteOff`: Keep existing format `'Detected ${eventInfo.$1} $eventNumber on channel ${channel + 1}'`

The cleanest approach: check `type` after the switch to decide message format:
```dart
final eventNumber = eventInfo.$2;
if (eventNumber != null) {
  _statusMessage = switch (type) {
    MidiEventType.cc14BitLowFirst || MidiEventType.cc14BitHighFirst =>
      '14-bit CC $eventNumber Ch ${channel + 1}',
    _ => 'Detected ${eventInfo.$1} $eventNumber on channel ${channel + 1}',
  };
  // ... callback logic unchanged
}
```

**Location 2 — BlocConsumer listener (around line 190-193):**
Same pattern. Currently:
```dart
_showStatusMessage(
  'Detected $eventTypeStr $eventNumber on channel ${lastDetectedChannel + 1}',
);
```
Change to use the same concise format for 14-bit types:
```dart
final message = switch (lastDetectedType) {
  MidiEventType.cc14BitLowFirst || MidiEventType.cc14BitHighFirst =>
    '14-bit CC $eventNumber Ch ${lastDetectedChannel + 1}',
  _ => 'Detected $eventTypeStr $eventNumber on channel ${lastDetectedChannel + 1}',
};
_showStatusMessage(message);
```

**IMPORTANT:** Do NOT change the `onMidiEventFound` callback invocations — they already correctly pass 14-bit types. Only change the status message text.

Run `flutter analyze` after changes — must be zero warnings.
  </action>
  <verify>
1. `flutter analyze` passes with zero warnings
2. Grep for "14-bit CC" in the file confirms both locations updated
3. Grep confirms no remaining "Detected.*14-bit" patterns (old format gone)
  </verify>
  <done>
14-bit detection shows "14-bit CC X Ch Y" format (5 words). 7-bit CC and note messages unchanged. Zero analyze warnings.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add widget tests for MidiDetectorWidget 14-bit integration</name>
  <files>test/ui/midi_listener/midi_detector_widget_test.dart</files>
  <action>
Create a new test file `test/ui/midi_listener/midi_detector_widget_test.dart`.

Follow existing test conventions from `test/ui/midi_listener/midi_listener_state_test.dart` and `test/ui/widgets/packed_mapping_data_editor_test.dart`.

The widget requires a `MidiListenerCubit` in the widget tree. The cubit uses `flutter_midi_command` package for device discovery. To test the status message rendering and callback behavior, use `BlocProvider` with a mock or real cubit that can have state set programmatically.

Since `MidiListenerCubit` uses `flutter_midi_command` which requires platform channels, the simplest approach is to test the STATUS MESSAGE LOGIC by verifying the switch expression behavior directly. Check if the existing test patterns use `mockito` or `mocktail` for bloc testing.

Check `test/` directory for existing bloc test patterns (e.g., `bloc_test`, `mocktail`). Match whatever testing approach is already used in the project.

**Tests to write:**

1. **Status message format for cc14BitLowFirst** — Verify the status message format would produce "14-bit CC X Ch Y" (not the old verbose format). This can be tested by examining the switch expression logic extracted or by constructing the state and asserting on the resulting message.

2. **Status message format for cc14BitHighFirst** — Same as above but for high-first variant.

3. **Status message format for 7-bit CC unchanged** — Verify standard CC still produces "Detected CC X on channel Y".

4. **Status message format for noteOn unchanged** — Verify noteOn still produces "Detected Note On X on channel Y".

5. **onMidiEventFound callback receives correct 14-bit type** — If widget testing is feasible with the project's mock setup, verify the callback fires with `MidiEventType.cc14BitLowFirst` when cubit emits that detection.

If full widget testing is impractical due to platform channel dependencies in `MidiListenerCubit`, write unit tests that verify the STATUS MESSAGE SWITCH EXPRESSION logic by extracting the formatting into a helper function first. In that case, add a static or top-level helper `formatDetectionMessage({required MidiEventType type, required String eventTypeStr, required int eventNumber, required int channel})` to `midi_detector_widget.dart` and test it directly.

Run `flutter test` to ensure all tests pass.
  </action>
  <verify>
1. `flutter test test/ui/midi_listener/` passes — all tests green
2. `flutter analyze` passes with zero warnings
3. Test file covers 14-bit message format assertions
  </verify>
  <done>
Widget tests exist verifying: 14-bit status message is concise, 7-bit/note messages unchanged, callback passes correct types. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `flutter analyze` — zero warnings
2. `flutter test` — all tests pass (existing + new)
3. Grep `midi_detector_widget.dart` for "14-bit CC" — confirms concise format in both locations
4. Grep `midi_detector_widget.dart` for "Detected.*14-bit" — confirms no remaining verbose 14-bit messages
5. All 5 Phase 3 success criteria verified:
   - SC1: Status message "14-bit CC X Ch Y" (concise) — updated in Task 1
   - SC2: onMidiEventFound delivers 14-bit type — already done (Phase 1)
   - SC3: Mapping editor auto-selects cc14BitLow/cc14BitHigh — already done (Phase 1)
   - SC4: CC number auto-filled from base CC — already done (Phase 1)
   - SC5: Range slider parameter-driven — non-issue (existing architecture)
</verification>

<success_criteria>
- Status message for 14-bit detection is exactly "14-bit CC {number} Ch {channel}" format
- 7-bit CC and note status messages remain in "Detected {type} {number} on channel {channel}" format
- All existing tests continue to pass
- New tests cover 14-bit status message format
- `flutter analyze` has zero warnings
- `flutter test` has zero failures
</success_criteria>

<output>
After completion, create `.planning/phases/03-ui-integration/03-01-SUMMARY.md`
</output>
