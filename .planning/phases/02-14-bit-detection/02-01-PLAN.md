---
phase: 02-14-bit-detection
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/ui/midi_listener/midi_detection_engine.dart
  - test/ui/midi_listener/midi_detection_engine_test.dart
autonomous: true

must_haves:
  truths:
    - "CC X and CC X+32 on the same channel form a 14-bit pair after both are seen"
    - "A pair hit only increments when BOTH CC X and CC X+32 have been received"
    - "14-bit pair detection reaches threshold after 10 pair hits"
    - "7-bit consecutive detection reaches threshold after 10 consecutive identical CCs"
    - "CC0/CC32 are excluded from 14-bit pairing (Bank Select)"
    - "First detector to reach threshold wins; the other's state is discarded"
    - "Byte order is determined by variance ratio of collected value samples"
    - "Ambiguous variance defaults to cc14BitLowFirst (standard MSB-first)"
    - "Only one pair can be active at a time (single pair lock)"
  artifacts:
    - path: "lib/ui/midi_listener/midi_detection_engine.dart"
      provides: "MidiDetectionEngine class with pair tracking, hit counting, byte order analysis"
      exports: ["MidiDetectionEngine", "DetectionResult"]
    - path: "test/ui/midi_listener/midi_detection_engine_test.dart"
      provides: "Comprehensive unit tests for all detection scenarios"
      min_lines: 200
  key_links:
    - from: "lib/ui/midi_listener/midi_detection_engine.dart"
      to: "lib/ui/midi_listener/midi_listener_cubit.dart"
      via: "imports MidiEventType enum"
      pattern: "import.*midi_listener_cubit"
---

<objective>
Create a standalone, testable MidiDetectionEngine class that implements parallel 7-bit and 14-bit CC detection with byte order analysis, using TDD (RED then GREEN).

Purpose: Extracts detection logic into a pure, testable unit separated from the cubit's Flutter/MIDI dependencies, enabling thorough testing of all detection scenarios (pair tracking, hit counting, Bank Select exclusion, byte order analysis, race conditions, reset behavior).

Output: A fully tested MidiDetectionEngine class and comprehensive test suite.
</objective>

<execution_context>
@/Users/nealsanche/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nealsanche/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-14-bit-detection/02-CONTEXT.md
@.planning/phases/02-14-bit-detection/02-RESEARCH.md
@.planning/phases/01-type-system-foundation/01-01-SUMMARY.md

# Source files for understanding existing types and patterns
@lib/ui/midi_listener/midi_listener_cubit.dart
@lib/ui/midi_listener/midi_listener_state.dart
@test/ui/midi_listener/midi_listener_state_test.dart
</context>

<feature>
  <name>MidiDetectionEngine - Parallel 7-bit/14-bit CC Detection with Byte Order Analysis</name>
  <files>lib/ui/midi_listener/midi_detection_engine.dart, test/ui/midi_listener/midi_detection_engine_test.dart</files>
  <behavior>
    The MidiDetectionEngine is a standalone class that processes CC messages and produces detection results.

    **API:**
    - `DetectionResult? processCc(int channel, int ccNumber, int ccValue)` — Feed a CC message. Returns non-null DetectionResult when threshold is reached.
    - `void processNoteOn(int channel, int note)` — Feed a Note On. Returns detection immediately (notes have threshold of 1).
    - `void processNoteOff(int channel, int note)` — Feed a Note Off. Returns detection immediately.
    - `void reset()` — Clear all tracking state (called on disconnect or externally).

    **DetectionResult** is a simple class/record:
    - `MidiEventType type` — The detected event type (cc, cc14BitLowFirst, cc14BitHighFirst, noteOn, noteOff)
    - `int channel` — MIDI channel (0-15)
    - `int number` — CC number (base CC for 14-bit) or note number

    **Internal state:**
    - 7-bit tracker: last event signature + consecutive count (mirrors existing cubit behavior)
    - 14-bit tracker: per-channel CC state map, active pair (nullable), pair hit count, value samples list
    - Threshold constant: 10 (for both 7-bit and 14-bit)

    **Behavior cases:**

    7-bit detection (existing behavior, preserved):
    - Input: 10 consecutive identical CC messages (same channel, same CC number)
    - Output: DetectionResult(type: cc, channel: N, number: ccNum)

    14-bit pair formation:
    - Input: CC 1 on ch 0, then CC 33 on ch 0
    - Effect: Pair (1, 33) locked on channel 0. No result yet.
    - Input: CC 5 on ch 0 after pair locked
    - Effect: Ignored for 14-bit (not part of active pair). Still counts for 7-bit.

    14-bit hit counting:
    - Input: CC 1 value=64 on ch 0, CC 33 value=100 on ch 0
    - Effect: 1 pair hit, sample recorded (low=64, high=100)
    - Input: CC 1 value=65 on ch 0 (no new CC 33 yet)
    - Effect: No new pair hit (need both to arrive again for next hit)
    - Note: After both CCs of a pair hit are seen, the "seen" flags reset so the next hit requires both CCs again.

    Bank Select exclusion:
    - Input: CC 0 on ch 0, CC 32 on ch 0
    - Effect: NO pair formed. These are processed as independent 7-bit CCs only.

    Byte order analysis (variance ratio):
    - Input: 10 value pairs where low CC values vary a lot, high CC values are stable
    - Output: cc14BitHighFirst (high CC = MSB because stable, low CC = LSB because varying)
    - Input: 10 value pairs where high CC values vary a lot, low CC values are stable
    - Output: cc14BitLowFirst (low CC = MSB because stable, high CC = LSB because varying)
    - Input: 10 value pairs where both vary similarly
    - Output: cc14BitLowFirst (default: standard MSB-first, lower CC = MSB)

    Race behavior:
    - 7-bit wins: If 10 consecutive identical CCs before 14-bit reaches 10 pair hits, emit 7-bit result, reset all state (both 7-bit and 14-bit)
    - 14-bit wins: If 10 pair hits before 7-bit reaches threshold, emit 14-bit result with byte order, reset all state

    Reset:
    - When any detection wins, both trackers reset
    - When reset() is called externally, both trackers reset
    - CC state map is kept across resets (per RESEARCH.md recommendation: bounded ~16KB, allows faster re-detection)

    Cross-channel isolation:
    - CC 1 on ch 0 and CC 33 on ch 1 do NOT form a pair (different channels)
  </behavior>
  <implementation>
    Create lib/ui/midi_listener/midi_detection_engine.dart:

    ```dart
    import 'dart:math';
    import 'package:meta/meta.dart';
    import 'midi_listener_cubit.dart'; // For MidiEventType

    class DetectionResult {
      final MidiEventType type;
      final int channel;
      final int number;
      const DetectionResult({required this.type, required this.channel, required this.number});
    }

    class MidiDetectionEngine {
      static const int kThreshold = 10;
      // Ambiguity threshold: ratios within [threshold, 1/threshold] are ambiguous
      @visibleForTesting
      static const double kAmbiguityThreshold = 0.8;

      // --- 7-bit state ---
      ({MidiEventType type, int channel, int number})? _lastEventSignature;
      int _consecutiveCount = 0;

      // --- 14-bit state ---
      // Track latest value per (channel, ccNumber) for pair detection
      final Map<(int, int), int> _ccValues = {};
      // Active pair tracking
      _PairTracker? _activePair;

      DetectionResult? processCc(int channel, int ccNumber, int ccValue) {
        // 1. Exclude Bank Select (CC0/CC32) from 14-bit pairing
        final bool isBankSelect = ccNumber == 0 || ccNumber == 32;

        // 2. Update CC value state
        _ccValues[(channel, ccNumber)] = ccValue;

        // 3. Update 14-bit pair tracker (if not Bank Select)
        if (!isBankSelect) {
          _update14BitTracker(channel, ccNumber, ccValue);
        }

        // 4. Update 7-bit consecutive tracker
        final signature = (type: MidiEventType.cc, channel: channel, number: ccNumber);
        if (signature == _lastEventSignature) {
          _consecutiveCount++;
        } else {
          _lastEventSignature = signature;
          _consecutiveCount = 1;
        }

        // 5. Check thresholds - 14-bit first (more specific wins on tie)
        if (_activePair != null && _activePair!.hitCount >= kThreshold) {
          final result = _build14BitResult();
          _resetDetectionState();
          return result;
        }
        if (_consecutiveCount >= kThreshold) {
          final result = DetectionResult(type: MidiEventType.cc, channel: channel, number: ccNumber);
          _resetDetectionState();
          return result;
        }

        return null;
      }

      DetectionResult? processNoteOn(int channel, int note) {
        final result = DetectionResult(type: MidiEventType.noteOn, channel: channel, number: note);
        _resetDetectionState();
        return result;
      }

      DetectionResult? processNoteOff(int channel, int note) {
        final result = DetectionResult(type: MidiEventType.noteOff, channel: channel, number: note);
        _resetDetectionState();
        return result;
      }

      void reset() {
        _resetDetectionState();
        _ccValues.clear();
      }

      // ... private methods for pair tracking, byte order analysis
    }
    ```

    The _update14BitTracker method:
    - If no active pair: check if ccNumber < 32 (potential MSB) and partner ccNumber+32 exists in _ccValues for same channel, OR if ccNumber >= 32 and ccNumber < 64 and partner ccNumber-32 exists. Either way, lock the pair with lowCc = min, highCc = max.
    - If active pair exists and this CC matches one of the pair's CCs on the correct channel: mark that side as "seen this round". If both sides seen, increment hitCount, record value sample, reset "seen" flags.

    The _build14BitResult method:
    - Call _determineByteOrder with collected value samples
    - Return DetectionResult with the determined type, pair channel, and base CC (lowCc)

    The _determineByteOrder method (static, @visibleForTesting):
    - Calculate variance of low CC values and high CC values from samples
    - Compute ratio = lowVariance / (highVariance + epsilon) to avoid div-by-zero
    - If ratio > 1/kAmbiguityThreshold: low varies more -> low is LSB -> cc14BitHighFirst
    - If ratio < kAmbiguityThreshold: high varies more -> high is LSB -> cc14BitLowFirst
    - Otherwise ambiguous: default to cc14BitLowFirst (standard MSB-first)

    The _resetDetectionState method:
    - Reset 7-bit: _lastEventSignature = null, _consecutiveCount = 0
    - Reset 14-bit: _activePair = null
    - Do NOT clear _ccValues (kept for re-detection performance)

    The _PairTracker private class:
    - channel, lowCc, highCc, hitCount
    - lowSeen/highSeen booleans for tracking within a single hit cycle
    - valueSamples list of (low: int, high: int) records
  </implementation>
</feature>

<verification>
- `flutter test test/ui/midi_listener/midi_detection_engine_test.dart` passes all tests
- `flutter analyze` reports zero warnings
- Tests cover: 7-bit consecutive detection, 14-bit pair formation, 14-bit hit counting, Bank Select exclusion, byte order analysis (MSB-first, LSB-first, ambiguous), race conditions (7-bit wins, 14-bit wins), reset behavior, cross-channel isolation
</verification>

<success_criteria>
- MidiDetectionEngine class exists with processCc, processNoteOn, processNoteOff, reset methods
- DetectionResult class exists with type, channel, number fields
- All detection scenarios pass unit tests
- 7-bit detection behavior matches existing cubit behavior exactly (10 consecutive hits)
- 14-bit pair detection works with eager lock, 10 pair hits, value analysis
- Bank Select (CC0/CC32) excluded from pairing
- Byte order determined by variance ratio with ambiguity default to cc14BitLowFirst
- Zero flutter analyze warnings
</success_criteria>

<output>
After completion, create `.planning/phases/02-14-bit-detection/02-01-SUMMARY.md`
</output>
