---
phase: 02-14-bit-detection
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - lib/ui/midi_listener/midi_listener_cubit.dart
autonomous: true

must_haves:
  truths:
    - "Cubit emits cc14BitLowFirst or cc14BitHighFirst when 14-bit detection wins"
    - "Cubit emits cc with correct CC number when 7-bit detection wins"
    - "Cubit emits noteOn/noteOff immediately (threshold of 1, existing behavior)"
    - "Disconnect resets all detection state"
    - "Existing 7-bit CC and note detection behavior unchanged"
  artifacts:
    - path: "lib/ui/midi_listener/midi_listener_cubit.dart"
      provides: "MidiListenerCubit using MidiDetectionEngine for parallel detection"
      contains: "MidiDetectionEngine"
  key_links:
    - from: "lib/ui/midi_listener/midi_listener_cubit.dart"
      to: "lib/ui/midi_listener/midi_detection_engine.dart"
      via: "import and field usage"
      pattern: "MidiDetectionEngine"
    - from: "lib/ui/midi_listener/midi_listener_cubit.dart"
      to: "lib/ui/midi_listener/midi_listener_state.dart"
      via: "emits Data state with detection results"
      pattern: "emit.*copyWith.*lastDetectedType"
---

<objective>
Wire the MidiDetectionEngine into MidiListenerCubit, replacing the inline 7-bit detection logic with the engine's parallel detection.

Purpose: The cubit becomes the thin integration layer between raw MIDI packets and the detection engine, delegating all detection logic to the tested engine while preserving the existing state emission pattern.

Output: Modified midi_listener_cubit.dart that uses MidiDetectionEngine for all detection.
</objective>

<execution_context>
@/Users/nealsanche/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nealsanche/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-14-bit-detection/02-CONTEXT.md
@.planning/phases/02-14-bit-detection/02-01-SUMMARY.md

# Source files
@lib/ui/midi_listener/midi_listener_cubit.dart
@lib/ui/midi_listener/midi_listener_state.dart
@lib/ui/midi_listener/midi_detection_engine.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace inline detection with MidiDetectionEngine</name>
  <files>lib/ui/midi_listener/midi_listener_cubit.dart</files>
  <action>
    Modify MidiListenerCubit to use MidiDetectionEngine instead of inline detection logic.

    Changes:
    1. Add `import 'midi_detection_engine.dart';` at top of file.

    2. Replace the inline 7-bit tracking fields:
       ```dart
       // REMOVE these:
       ({MidiEventType type, int channel, int number})? _lastEventSignature;
       int _consecutiveCount = 0;

       // ADD this:
       final MidiDetectionEngine _detectionEngine = MidiDetectionEngine();
       ```

    3. Rewrite `_handleMidiData` to delegate to the engine:
       ```dart
       void _handleMidiData(MidiPacket packet) {
         final data = packet.data;
         if (data.isEmpty || data.length < 3) return;

         final statusByte = data[0];
         final messageType = statusByte & 0xF0;
         final channel = statusByte & 0x0F;

         DetectionResult? result;

         if (messageType == 0xB0) {
           // CC message
           result = _detectionEngine.processCc(channel, data[1], data[2]);
         } else if (messageType == 0x90) {
           // Note On (velocity 0 = Note Off)
           final note = data[1];
           final velocity = data[2];
           result = velocity == 0
               ? _detectionEngine.processNoteOff(channel, note)
               : _detectionEngine.processNoteOn(channel, note);
         } else if (messageType == 0x80) {
           // Note Off
           result = _detectionEngine.processNoteOff(channel, data[1]);
         }

         if (result != null) {
           _emitDetectionResult(result);
         }
       }
       ```

    4. Add `_emitDetectionResult` method:
       ```dart
       void _emitDetectionResult(DetectionResult result) {
         final currentState = state;
         if (currentState is Data) {
           final isCcType = result.type == MidiEventType.cc ||
               result.type == MidiEventType.cc14BitLowFirst ||
               result.type == MidiEventType.cc14BitHighFirst;

           emit(currentState.copyWith(
             lastDetectedType: result.type,
             lastDetectedChannel: result.channel,
             lastDetectedCc: isCcType ? result.number : null,
             lastDetectedNote: !isCcType ? result.number : null,
             lastDetectedTime: DateTime.timestamp(),
           ));
         }
       }
       ```

    5. Update `disconnectDevice` to reset the engine:
       Replace the two lines:
       ```dart
       _consecutiveCount = 0;
       _lastEventSignature = null;
       ```
       With:
       ```dart
       _detectionEngine.reset();
       ```

    6. Remove the `static const int kThreshold = 10;` line from the cubit (threshold now lives in the engine).

    IMPORTANT: Do NOT change the note detection behavior. Notes should still emit immediately (the engine handles this by returning a result on every note). The engine's processCc handles the parallel 7-bit/14-bit race internally.

    IMPORTANT: Do NOT remove the empty debug print blocks (lines 177-178, 189-192 in current file). They are placeholders the user may use.

    IMPORTANT: Preserve the existing state emission for notes. Currently notes emit with lastDetectedType set (threshold is always met for notes). The engine returns a DetectionResult immediately for notes, which the cubit emits. For CC messages that don't meet threshold, the engine returns null, and the cubit should still emit a state update with null detection fields (to update lastDetectedTime for activity indication). Actually, looking at the existing code more carefully: the cubit currently emits for EVERY CC message, with thresholdMet determining whether lastDetectedType is set or null. The engine returns null for sub-threshold CCs. To preserve the existing behavior of emitting state updates (with null type) for every MIDI message, add a fallback emit when engine returns null:

    ```dart
    if (result != null) {
      _emitDetectionResult(result);
    } else if (messageType == 0xB0 || messageType == 0x90 || messageType == 0x80) {
      // Sub-threshold: emit state update with null detection (preserves activity indication)
      final currentState = state;
      if (currentState is Data) {
        emit(currentState.copyWith(
          lastDetectedType: null,
          lastDetectedChannel: null,
          lastDetectedCc: null,
          lastDetectedNote: null,
          lastDetectedTime: DateTime.timestamp(),
        ));
      }
    }
    ```
  </action>
  <verify>
    1. `flutter analyze` reports zero warnings
    2. `flutter test` — all existing tests pass (no regressions)
    3. Verify the cubit file compiles and the engine import resolves
  </verify>
  <done>
    - MidiListenerCubit uses MidiDetectionEngine for all detection logic
    - No inline 7-bit tracking state remains in the cubit (moved to engine)
    - kThreshold removed from cubit (lives in engine)
    - disconnectDevice resets the engine
    - Existing note detection behavior preserved (immediate emit)
    - Existing 7-bit CC detection behavior preserved (10 consecutive hits)
    - New 14-bit CC detection works through the engine
    - flutter analyze: zero warnings
    - flutter test: all tests pass
  </done>
</task>

</tasks>

<verification>
- `flutter analyze` — zero warnings
- `flutter test` — all tests pass, including the Phase 1 midi_listener_state_test.dart
- The cubit no longer has _lastEventSignature, _consecutiveCount, or kThreshold fields
- The cubit has a _detectionEngine field of type MidiDetectionEngine
- _handleMidiData delegates to the engine and emits results
- disconnectDevice calls _detectionEngine.reset()
</verification>

<success_criteria>
- MidiListenerCubit delegates all detection to MidiDetectionEngine
- No inline detection state in the cubit
- All existing tests pass (7-bit CC, note detection behavior unchanged)
- 14-bit detection results flow through cubit state emission
- Zero flutter analyze warnings
</success_criteria>

<output>
After completion, create `.planning/phases/02-14-bit-detection/02-02-SUMMARY.md`
</output>
