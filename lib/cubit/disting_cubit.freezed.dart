// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'disting_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$Slot {
  Algorithm get algorithm => throw _privateConstructorUsedError;
  RoutingInfo get routing => throw _privateConstructorUsedError;
  ParameterPages get pages => throw _privateConstructorUsedError;
  List<ParameterInfo> get parameters => throw _privateConstructorUsedError;
  List<ParameterValue> get values => throw _privateConstructorUsedError;
  List<ParameterEnumStrings> get enums => throw _privateConstructorUsedError;
  List<Mapping> get mappings => throw _privateConstructorUsedError;
  List<ParameterValueString> get valueStrings =>
      throw _privateConstructorUsedError;

  /// Create a copy of Slot
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SlotCopyWith<Slot> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SlotCopyWith<$Res> {
  factory $SlotCopyWith(Slot value, $Res Function(Slot) then) =
      _$SlotCopyWithImpl<$Res, Slot>;
  @useResult
  $Res call(
      {Algorithm algorithm,
      RoutingInfo routing,
      ParameterPages pages,
      List<ParameterInfo> parameters,
      List<ParameterValue> values,
      List<ParameterEnumStrings> enums,
      List<Mapping> mappings,
      List<ParameterValueString> valueStrings});
}

/// @nodoc
class _$SlotCopyWithImpl<$Res, $Val extends Slot>
    implements $SlotCopyWith<$Res> {
  _$SlotCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Slot
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? algorithm = null,
    Object? routing = null,
    Object? pages = null,
    Object? parameters = null,
    Object? values = null,
    Object? enums = null,
    Object? mappings = null,
    Object? valueStrings = null,
  }) {
    return _then(_value.copyWith(
      algorithm: null == algorithm
          ? _value.algorithm
          : algorithm // ignore: cast_nullable_to_non_nullable
              as Algorithm,
      routing: null == routing
          ? _value.routing
          : routing // ignore: cast_nullable_to_non_nullable
              as RoutingInfo,
      pages: null == pages
          ? _value.pages
          : pages // ignore: cast_nullable_to_non_nullable
              as ParameterPages,
      parameters: null == parameters
          ? _value.parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<ParameterInfo>,
      values: null == values
          ? _value.values
          : values // ignore: cast_nullable_to_non_nullable
              as List<ParameterValue>,
      enums: null == enums
          ? _value.enums
          : enums // ignore: cast_nullable_to_non_nullable
              as List<ParameterEnumStrings>,
      mappings: null == mappings
          ? _value.mappings
          : mappings // ignore: cast_nullable_to_non_nullable
              as List<Mapping>,
      valueStrings: null == valueStrings
          ? _value.valueStrings
          : valueStrings // ignore: cast_nullable_to_non_nullable
              as List<ParameterValueString>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SlotImplCopyWith<$Res> implements $SlotCopyWith<$Res> {
  factory _$$SlotImplCopyWith(
          _$SlotImpl value, $Res Function(_$SlotImpl) then) =
      __$$SlotImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Algorithm algorithm,
      RoutingInfo routing,
      ParameterPages pages,
      List<ParameterInfo> parameters,
      List<ParameterValue> values,
      List<ParameterEnumStrings> enums,
      List<Mapping> mappings,
      List<ParameterValueString> valueStrings});
}

/// @nodoc
class __$$SlotImplCopyWithImpl<$Res>
    extends _$SlotCopyWithImpl<$Res, _$SlotImpl>
    implements _$$SlotImplCopyWith<$Res> {
  __$$SlotImplCopyWithImpl(_$SlotImpl _value, $Res Function(_$SlotImpl) _then)
      : super(_value, _then);

  /// Create a copy of Slot
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? algorithm = null,
    Object? routing = null,
    Object? pages = null,
    Object? parameters = null,
    Object? values = null,
    Object? enums = null,
    Object? mappings = null,
    Object? valueStrings = null,
  }) {
    return _then(_$SlotImpl(
      algorithm: null == algorithm
          ? _value.algorithm
          : algorithm // ignore: cast_nullable_to_non_nullable
              as Algorithm,
      routing: null == routing
          ? _value.routing
          : routing // ignore: cast_nullable_to_non_nullable
              as RoutingInfo,
      pages: null == pages
          ? _value.pages
          : pages // ignore: cast_nullable_to_non_nullable
              as ParameterPages,
      parameters: null == parameters
          ? _value._parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<ParameterInfo>,
      values: null == values
          ? _value._values
          : values // ignore: cast_nullable_to_non_nullable
              as List<ParameterValue>,
      enums: null == enums
          ? _value._enums
          : enums // ignore: cast_nullable_to_non_nullable
              as List<ParameterEnumStrings>,
      mappings: null == mappings
          ? _value._mappings
          : mappings // ignore: cast_nullable_to_non_nullable
              as List<Mapping>,
      valueStrings: null == valueStrings
          ? _value._valueStrings
          : valueStrings // ignore: cast_nullable_to_non_nullable
              as List<ParameterValueString>,
    ));
  }
}

/// @nodoc

class _$SlotImpl with DiagnosticableTreeMixin implements _Slot {
  const _$SlotImpl(
      {required this.algorithm,
      required this.routing,
      required this.pages,
      required final List<ParameterInfo> parameters,
      required final List<ParameterValue> values,
      required final List<ParameterEnumStrings> enums,
      required final List<Mapping> mappings,
      required final List<ParameterValueString> valueStrings})
      : _parameters = parameters,
        _values = values,
        _enums = enums,
        _mappings = mappings,
        _valueStrings = valueStrings;

  @override
  final Algorithm algorithm;
  @override
  final RoutingInfo routing;
  @override
  final ParameterPages pages;
  final List<ParameterInfo> _parameters;
  @override
  List<ParameterInfo> get parameters {
    if (_parameters is EqualUnmodifiableListView) return _parameters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_parameters);
  }

  final List<ParameterValue> _values;
  @override
  List<ParameterValue> get values {
    if (_values is EqualUnmodifiableListView) return _values;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_values);
  }

  final List<ParameterEnumStrings> _enums;
  @override
  List<ParameterEnumStrings> get enums {
    if (_enums is EqualUnmodifiableListView) return _enums;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_enums);
  }

  final List<Mapping> _mappings;
  @override
  List<Mapping> get mappings {
    if (_mappings is EqualUnmodifiableListView) return _mappings;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_mappings);
  }

  final List<ParameterValueString> _valueStrings;
  @override
  List<ParameterValueString> get valueStrings {
    if (_valueStrings is EqualUnmodifiableListView) return _valueStrings;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_valueStrings);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Slot(algorithm: $algorithm, routing: $routing, pages: $pages, parameters: $parameters, values: $values, enums: $enums, mappings: $mappings, valueStrings: $valueStrings)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Slot'))
      ..add(DiagnosticsProperty('algorithm', algorithm))
      ..add(DiagnosticsProperty('routing', routing))
      ..add(DiagnosticsProperty('pages', pages))
      ..add(DiagnosticsProperty('parameters', parameters))
      ..add(DiagnosticsProperty('values', values))
      ..add(DiagnosticsProperty('enums', enums))
      ..add(DiagnosticsProperty('mappings', mappings))
      ..add(DiagnosticsProperty('valueStrings', valueStrings));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SlotImpl &&
            (identical(other.algorithm, algorithm) ||
                other.algorithm == algorithm) &&
            (identical(other.routing, routing) || other.routing == routing) &&
            (identical(other.pages, pages) || other.pages == pages) &&
            const DeepCollectionEquality()
                .equals(other._parameters, _parameters) &&
            const DeepCollectionEquality().equals(other._values, _values) &&
            const DeepCollectionEquality().equals(other._enums, _enums) &&
            const DeepCollectionEquality().equals(other._mappings, _mappings) &&
            const DeepCollectionEquality()
                .equals(other._valueStrings, _valueStrings));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      algorithm,
      routing,
      pages,
      const DeepCollectionEquality().hash(_parameters),
      const DeepCollectionEquality().hash(_values),
      const DeepCollectionEquality().hash(_enums),
      const DeepCollectionEquality().hash(_mappings),
      const DeepCollectionEquality().hash(_valueStrings));

  /// Create a copy of Slot
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SlotImplCopyWith<_$SlotImpl> get copyWith =>
      __$$SlotImplCopyWithImpl<_$SlotImpl>(this, _$identity);
}

abstract class _Slot implements Slot {
  const factory _Slot(
      {required final Algorithm algorithm,
      required final RoutingInfo routing,
      required final ParameterPages pages,
      required final List<ParameterInfo> parameters,
      required final List<ParameterValue> values,
      required final List<ParameterEnumStrings> enums,
      required final List<Mapping> mappings,
      required final List<ParameterValueString> valueStrings}) = _$SlotImpl;

  @override
  Algorithm get algorithm;
  @override
  RoutingInfo get routing;
  @override
  ParameterPages get pages;
  @override
  List<ParameterInfo> get parameters;
  @override
  List<ParameterValue> get values;
  @override
  List<ParameterEnumStrings> get enums;
  @override
  List<Mapping> get mappings;
  @override
  List<ParameterValueString> get valueStrings;

  /// Create a copy of Slot
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SlotImplCopyWith<_$SlotImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$MappedParameter {
  ParameterInfo get parameter => throw _privateConstructorUsedError;
  ParameterValue get value => throw _privateConstructorUsedError;
  ParameterEnumStrings get enums => throw _privateConstructorUsedError;
  ParameterValueString get valueString => throw _privateConstructorUsedError;
  Mapping get mapping => throw _privateConstructorUsedError;
  Algorithm get algorithm => throw _privateConstructorUsedError;

  /// Create a copy of MappedParameter
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MappedParameterCopyWith<MappedParameter> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MappedParameterCopyWith<$Res> {
  factory $MappedParameterCopyWith(
          MappedParameter value, $Res Function(MappedParameter) then) =
      _$MappedParameterCopyWithImpl<$Res, MappedParameter>;
  @useResult
  $Res call(
      {ParameterInfo parameter,
      ParameterValue value,
      ParameterEnumStrings enums,
      ParameterValueString valueString,
      Mapping mapping,
      Algorithm algorithm});
}

/// @nodoc
class _$MappedParameterCopyWithImpl<$Res, $Val extends MappedParameter>
    implements $MappedParameterCopyWith<$Res> {
  _$MappedParameterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of MappedParameter
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? parameter = null,
    Object? value = null,
    Object? enums = null,
    Object? valueString = null,
    Object? mapping = null,
    Object? algorithm = null,
  }) {
    return _then(_value.copyWith(
      parameter: null == parameter
          ? _value.parameter
          : parameter // ignore: cast_nullable_to_non_nullable
              as ParameterInfo,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ParameterValue,
      enums: null == enums
          ? _value.enums
          : enums // ignore: cast_nullable_to_non_nullable
              as ParameterEnumStrings,
      valueString: null == valueString
          ? _value.valueString
          : valueString // ignore: cast_nullable_to_non_nullable
              as ParameterValueString,
      mapping: null == mapping
          ? _value.mapping
          : mapping // ignore: cast_nullable_to_non_nullable
              as Mapping,
      algorithm: null == algorithm
          ? _value.algorithm
          : algorithm // ignore: cast_nullable_to_non_nullable
              as Algorithm,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MappedParameterImplCopyWith<$Res>
    implements $MappedParameterCopyWith<$Res> {
  factory _$$MappedParameterImplCopyWith(_$MappedParameterImpl value,
          $Res Function(_$MappedParameterImpl) then) =
      __$$MappedParameterImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {ParameterInfo parameter,
      ParameterValue value,
      ParameterEnumStrings enums,
      ParameterValueString valueString,
      Mapping mapping,
      Algorithm algorithm});
}

/// @nodoc
class __$$MappedParameterImplCopyWithImpl<$Res>
    extends _$MappedParameterCopyWithImpl<$Res, _$MappedParameterImpl>
    implements _$$MappedParameterImplCopyWith<$Res> {
  __$$MappedParameterImplCopyWithImpl(
      _$MappedParameterImpl _value, $Res Function(_$MappedParameterImpl) _then)
      : super(_value, _then);

  /// Create a copy of MappedParameter
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? parameter = null,
    Object? value = null,
    Object? enums = null,
    Object? valueString = null,
    Object? mapping = null,
    Object? algorithm = null,
  }) {
    return _then(_$MappedParameterImpl(
      parameter: null == parameter
          ? _value.parameter
          : parameter // ignore: cast_nullable_to_non_nullable
              as ParameterInfo,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as ParameterValue,
      enums: null == enums
          ? _value.enums
          : enums // ignore: cast_nullable_to_non_nullable
              as ParameterEnumStrings,
      valueString: null == valueString
          ? _value.valueString
          : valueString // ignore: cast_nullable_to_non_nullable
              as ParameterValueString,
      mapping: null == mapping
          ? _value.mapping
          : mapping // ignore: cast_nullable_to_non_nullable
              as Mapping,
      algorithm: null == algorithm
          ? _value.algorithm
          : algorithm // ignore: cast_nullable_to_non_nullable
              as Algorithm,
    ));
  }
}

/// @nodoc

class _$MappedParameterImpl
    with DiagnosticableTreeMixin
    implements _MappedParameter {
  const _$MappedParameterImpl(
      {required this.parameter,
      required this.value,
      required this.enums,
      required this.valueString,
      required this.mapping,
      required this.algorithm});

  @override
  final ParameterInfo parameter;
  @override
  final ParameterValue value;
  @override
  final ParameterEnumStrings enums;
  @override
  final ParameterValueString valueString;
  @override
  final Mapping mapping;
  @override
  final Algorithm algorithm;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MappedParameter(parameter: $parameter, value: $value, enums: $enums, valueString: $valueString, mapping: $mapping, algorithm: $algorithm)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'MappedParameter'))
      ..add(DiagnosticsProperty('parameter', parameter))
      ..add(DiagnosticsProperty('value', value))
      ..add(DiagnosticsProperty('enums', enums))
      ..add(DiagnosticsProperty('valueString', valueString))
      ..add(DiagnosticsProperty('mapping', mapping))
      ..add(DiagnosticsProperty('algorithm', algorithm));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MappedParameterImpl &&
            (identical(other.parameter, parameter) ||
                other.parameter == parameter) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.enums, enums) || other.enums == enums) &&
            (identical(other.valueString, valueString) ||
                other.valueString == valueString) &&
            (identical(other.mapping, mapping) || other.mapping == mapping) &&
            (identical(other.algorithm, algorithm) ||
                other.algorithm == algorithm));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, parameter, value, enums, valueString, mapping, algorithm);

  /// Create a copy of MappedParameter
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MappedParameterImplCopyWith<_$MappedParameterImpl> get copyWith =>
      __$$MappedParameterImplCopyWithImpl<_$MappedParameterImpl>(
          this, _$identity);
}

abstract class _MappedParameter implements MappedParameter {
  const factory _MappedParameter(
      {required final ParameterInfo parameter,
      required final ParameterValue value,
      required final ParameterEnumStrings enums,
      required final ParameterValueString valueString,
      required final Mapping mapping,
      required final Algorithm algorithm}) = _$MappedParameterImpl;

  @override
  ParameterInfo get parameter;
  @override
  ParameterValue get value;
  @override
  ParameterEnumStrings get enums;
  @override
  ParameterValueString get valueString;
  @override
  Mapping get mapping;
  @override
  Algorithm get algorithm;

  /// Create a copy of MappedParameter
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MappedParameterImplCopyWith<_$MappedParameterImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DistingState {
  Uint8List? get screenshot => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Uint8List? screenshot) initial,
    required TResult Function(List<MidiDevice> inputDevices,
            List<MidiDevice> outputDevices, Uint8List? screenshot)
        selectDevice,
    required TResult Function(DistingMidiManager disting, Uint8List? screenshot)
        connected,
    required TResult Function(
            DistingMidiManager disting,
            String distingVersion,
            String presetName,
            List<AlgorithmInfo> algorithms,
            List<Slot> slots,
            List<String> unitStrings,
            Uint8List? screenshot,
            bool loading)
        synchronized,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Uint8List? screenshot)? initial,
    TResult? Function(List<MidiDevice> inputDevices,
            List<MidiDevice> outputDevices, Uint8List? screenshot)?
        selectDevice,
    TResult? Function(DistingMidiManager disting, Uint8List? screenshot)?
        connected,
    TResult? Function(
            DistingMidiManager disting,
            String distingVersion,
            String presetName,
            List<AlgorithmInfo> algorithms,
            List<Slot> slots,
            List<String> unitStrings,
            Uint8List? screenshot,
            bool loading)?
        synchronized,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Uint8List? screenshot)? initial,
    TResult Function(List<MidiDevice> inputDevices,
            List<MidiDevice> outputDevices, Uint8List? screenshot)?
        selectDevice,
    TResult Function(DistingMidiManager disting, Uint8List? screenshot)?
        connected,
    TResult Function(
            DistingMidiManager disting,
            String distingVersion,
            String presetName,
            List<AlgorithmInfo> algorithms,
            List<Slot> slots,
            List<String> unitStrings,
            Uint8List? screenshot,
            bool loading)?
        synchronized,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DistingStateInitial value) initial,
    required TResult Function(DistingStateSelectDevice value) selectDevice,
    required TResult Function(DistingStateConnected value) connected,
    required TResult Function(DistingStateSynchronized value) synchronized,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DistingStateInitial value)? initial,
    TResult? Function(DistingStateSelectDevice value)? selectDevice,
    TResult? Function(DistingStateConnected value)? connected,
    TResult? Function(DistingStateSynchronized value)? synchronized,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DistingStateInitial value)? initial,
    TResult Function(DistingStateSelectDevice value)? selectDevice,
    TResult Function(DistingStateConnected value)? connected,
    TResult Function(DistingStateSynchronized value)? synchronized,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Create a copy of DistingState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DistingStateCopyWith<DistingState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DistingStateCopyWith<$Res> {
  factory $DistingStateCopyWith(
          DistingState value, $Res Function(DistingState) then) =
      _$DistingStateCopyWithImpl<$Res, DistingState>;
  @useResult
  $Res call({Uint8List? screenshot});
}

/// @nodoc
class _$DistingStateCopyWithImpl<$Res, $Val extends DistingState>
    implements $DistingStateCopyWith<$Res> {
  _$DistingStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DistingState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? screenshot = freezed,
  }) {
    return _then(_value.copyWith(
      screenshot: freezed == screenshot
          ? _value.screenshot
          : screenshot // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DistingStateInitialImplCopyWith<$Res>
    implements $DistingStateCopyWith<$Res> {
  factory _$$DistingStateInitialImplCopyWith(_$DistingStateInitialImpl value,
          $Res Function(_$DistingStateInitialImpl) then) =
      __$$DistingStateInitialImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Uint8List? screenshot});
}

/// @nodoc
class __$$DistingStateInitialImplCopyWithImpl<$Res>
    extends _$DistingStateCopyWithImpl<$Res, _$DistingStateInitialImpl>
    implements _$$DistingStateInitialImplCopyWith<$Res> {
  __$$DistingStateInitialImplCopyWithImpl(_$DistingStateInitialImpl _value,
      $Res Function(_$DistingStateInitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of DistingState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? screenshot = freezed,
  }) {
    return _then(_$DistingStateInitialImpl(
      screenshot: freezed == screenshot
          ? _value.screenshot
          : screenshot // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
    ));
  }
}

/// @nodoc

class _$DistingStateInitialImpl
    with DiagnosticableTreeMixin
    implements DistingStateInitial {
  const _$DistingStateInitialImpl({this.screenshot});

  @override
  final Uint8List? screenshot;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'DistingState.initial(screenshot: $screenshot)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'DistingState.initial'))
      ..add(DiagnosticsProperty('screenshot', screenshot));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DistingStateInitialImpl &&
            const DeepCollectionEquality()
                .equals(other.screenshot, screenshot));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(screenshot));

  /// Create a copy of DistingState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DistingStateInitialImplCopyWith<_$DistingStateInitialImpl> get copyWith =>
      __$$DistingStateInitialImplCopyWithImpl<_$DistingStateInitialImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Uint8List? screenshot) initial,
    required TResult Function(List<MidiDevice> inputDevices,
            List<MidiDevice> outputDevices, Uint8List? screenshot)
        selectDevice,
    required TResult Function(DistingMidiManager disting, Uint8List? screenshot)
        connected,
    required TResult Function(
            DistingMidiManager disting,
            String distingVersion,
            String presetName,
            List<AlgorithmInfo> algorithms,
            List<Slot> slots,
            List<String> unitStrings,
            Uint8List? screenshot,
            bool loading)
        synchronized,
  }) {
    return initial(screenshot);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Uint8List? screenshot)? initial,
    TResult? Function(List<MidiDevice> inputDevices,
            List<MidiDevice> outputDevices, Uint8List? screenshot)?
        selectDevice,
    TResult? Function(DistingMidiManager disting, Uint8List? screenshot)?
        connected,
    TResult? Function(
            DistingMidiManager disting,
            String distingVersion,
            String presetName,
            List<AlgorithmInfo> algorithms,
            List<Slot> slots,
            List<String> unitStrings,
            Uint8List? screenshot,
            bool loading)?
        synchronized,
  }) {
    return initial?.call(screenshot);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Uint8List? screenshot)? initial,
    TResult Function(List<MidiDevice> inputDevices,
            List<MidiDevice> outputDevices, Uint8List? screenshot)?
        selectDevice,
    TResult Function(DistingMidiManager disting, Uint8List? screenshot)?
        connected,
    TResult Function(
            DistingMidiManager disting,
            String distingVersion,
            String presetName,
            List<AlgorithmInfo> algorithms,
            List<Slot> slots,
            List<String> unitStrings,
            Uint8List? screenshot,
            bool loading)?
        synchronized,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(screenshot);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DistingStateInitial value) initial,
    required TResult Function(DistingStateSelectDevice value) selectDevice,
    required TResult Function(DistingStateConnected value) connected,
    required TResult Function(DistingStateSynchronized value) synchronized,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DistingStateInitial value)? initial,
    TResult? Function(DistingStateSelectDevice value)? selectDevice,
    TResult? Function(DistingStateConnected value)? connected,
    TResult? Function(DistingStateSynchronized value)? synchronized,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DistingStateInitial value)? initial,
    TResult Function(DistingStateSelectDevice value)? selectDevice,
    TResult Function(DistingStateConnected value)? connected,
    TResult Function(DistingStateSynchronized value)? synchronized,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class DistingStateInitial implements DistingState {
  const factory DistingStateInitial({final Uint8List? screenshot}) =
      _$DistingStateInitialImpl;

  @override
  Uint8List? get screenshot;

  /// Create a copy of DistingState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DistingStateInitialImplCopyWith<_$DistingStateInitialImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DistingStateSelectDeviceImplCopyWith<$Res>
    implements $DistingStateCopyWith<$Res> {
  factory _$$DistingStateSelectDeviceImplCopyWith(
          _$DistingStateSelectDeviceImpl value,
          $Res Function(_$DistingStateSelectDeviceImpl) then) =
      __$$DistingStateSelectDeviceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<MidiDevice> inputDevices,
      List<MidiDevice> outputDevices,
      Uint8List? screenshot});
}

/// @nodoc
class __$$DistingStateSelectDeviceImplCopyWithImpl<$Res>
    extends _$DistingStateCopyWithImpl<$Res, _$DistingStateSelectDeviceImpl>
    implements _$$DistingStateSelectDeviceImplCopyWith<$Res> {
  __$$DistingStateSelectDeviceImplCopyWithImpl(
      _$DistingStateSelectDeviceImpl _value,
      $Res Function(_$DistingStateSelectDeviceImpl) _then)
      : super(_value, _then);

  /// Create a copy of DistingState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? inputDevices = null,
    Object? outputDevices = null,
    Object? screenshot = freezed,
  }) {
    return _then(_$DistingStateSelectDeviceImpl(
      inputDevices: null == inputDevices
          ? _value._inputDevices
          : inputDevices // ignore: cast_nullable_to_non_nullable
              as List<MidiDevice>,
      outputDevices: null == outputDevices
          ? _value._outputDevices
          : outputDevices // ignore: cast_nullable_to_non_nullable
              as List<MidiDevice>,
      screenshot: freezed == screenshot
          ? _value.screenshot
          : screenshot // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
    ));
  }
}

/// @nodoc

class _$DistingStateSelectDeviceImpl
    with DiagnosticableTreeMixin
    implements DistingStateSelectDevice {
  const _$DistingStateSelectDeviceImpl(
      {required final List<MidiDevice> inputDevices,
      required final List<MidiDevice> outputDevices,
      this.screenshot})
      : _inputDevices = inputDevices,
        _outputDevices = outputDevices;

  final List<MidiDevice> _inputDevices;
  @override
  List<MidiDevice> get inputDevices {
    if (_inputDevices is EqualUnmodifiableListView) return _inputDevices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_inputDevices);
  }

  final List<MidiDevice> _outputDevices;
  @override
  List<MidiDevice> get outputDevices {
    if (_outputDevices is EqualUnmodifiableListView) return _outputDevices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_outputDevices);
  }

  @override
  final Uint8List? screenshot;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'DistingState.selectDevice(inputDevices: $inputDevices, outputDevices: $outputDevices, screenshot: $screenshot)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'DistingState.selectDevice'))
      ..add(DiagnosticsProperty('inputDevices', inputDevices))
      ..add(DiagnosticsProperty('outputDevices', outputDevices))
      ..add(DiagnosticsProperty('screenshot', screenshot));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DistingStateSelectDeviceImpl &&
            const DeepCollectionEquality()
                .equals(other._inputDevices, _inputDevices) &&
            const DeepCollectionEquality()
                .equals(other._outputDevices, _outputDevices) &&
            const DeepCollectionEquality()
                .equals(other.screenshot, screenshot));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_inputDevices),
      const DeepCollectionEquality().hash(_outputDevices),
      const DeepCollectionEquality().hash(screenshot));

  /// Create a copy of DistingState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DistingStateSelectDeviceImplCopyWith<_$DistingStateSelectDeviceImpl>
      get copyWith => __$$DistingStateSelectDeviceImplCopyWithImpl<
          _$DistingStateSelectDeviceImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Uint8List? screenshot) initial,
    required TResult Function(List<MidiDevice> inputDevices,
            List<MidiDevice> outputDevices, Uint8List? screenshot)
        selectDevice,
    required TResult Function(DistingMidiManager disting, Uint8List? screenshot)
        connected,
    required TResult Function(
            DistingMidiManager disting,
            String distingVersion,
            String presetName,
            List<AlgorithmInfo> algorithms,
            List<Slot> slots,
            List<String> unitStrings,
            Uint8List? screenshot,
            bool loading)
        synchronized,
  }) {
    return selectDevice(inputDevices, outputDevices, screenshot);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Uint8List? screenshot)? initial,
    TResult? Function(List<MidiDevice> inputDevices,
            List<MidiDevice> outputDevices, Uint8List? screenshot)?
        selectDevice,
    TResult? Function(DistingMidiManager disting, Uint8List? screenshot)?
        connected,
    TResult? Function(
            DistingMidiManager disting,
            String distingVersion,
            String presetName,
            List<AlgorithmInfo> algorithms,
            List<Slot> slots,
            List<String> unitStrings,
            Uint8List? screenshot,
            bool loading)?
        synchronized,
  }) {
    return selectDevice?.call(inputDevices, outputDevices, screenshot);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Uint8List? screenshot)? initial,
    TResult Function(List<MidiDevice> inputDevices,
            List<MidiDevice> outputDevices, Uint8List? screenshot)?
        selectDevice,
    TResult Function(DistingMidiManager disting, Uint8List? screenshot)?
        connected,
    TResult Function(
            DistingMidiManager disting,
            String distingVersion,
            String presetName,
            List<AlgorithmInfo> algorithms,
            List<Slot> slots,
            List<String> unitStrings,
            Uint8List? screenshot,
            bool loading)?
        synchronized,
    required TResult orElse(),
  }) {
    if (selectDevice != null) {
      return selectDevice(inputDevices, outputDevices, screenshot);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DistingStateInitial value) initial,
    required TResult Function(DistingStateSelectDevice value) selectDevice,
    required TResult Function(DistingStateConnected value) connected,
    required TResult Function(DistingStateSynchronized value) synchronized,
  }) {
    return selectDevice(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DistingStateInitial value)? initial,
    TResult? Function(DistingStateSelectDevice value)? selectDevice,
    TResult? Function(DistingStateConnected value)? connected,
    TResult? Function(DistingStateSynchronized value)? synchronized,
  }) {
    return selectDevice?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DistingStateInitial value)? initial,
    TResult Function(DistingStateSelectDevice value)? selectDevice,
    TResult Function(DistingStateConnected value)? connected,
    TResult Function(DistingStateSynchronized value)? synchronized,
    required TResult orElse(),
  }) {
    if (selectDevice != null) {
      return selectDevice(this);
    }
    return orElse();
  }
}

abstract class DistingStateSelectDevice implements DistingState {
  const factory DistingStateSelectDevice(
      {required final List<MidiDevice> inputDevices,
      required final List<MidiDevice> outputDevices,
      final Uint8List? screenshot}) = _$DistingStateSelectDeviceImpl;

  List<MidiDevice> get inputDevices;
  List<MidiDevice> get outputDevices;
  @override
  Uint8List? get screenshot;

  /// Create a copy of DistingState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DistingStateSelectDeviceImplCopyWith<_$DistingStateSelectDeviceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DistingStateConnectedImplCopyWith<$Res>
    implements $DistingStateCopyWith<$Res> {
  factory _$$DistingStateConnectedImplCopyWith(
          _$DistingStateConnectedImpl value,
          $Res Function(_$DistingStateConnectedImpl) then) =
      __$$DistingStateConnectedImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({DistingMidiManager disting, Uint8List? screenshot});
}

/// @nodoc
class __$$DistingStateConnectedImplCopyWithImpl<$Res>
    extends _$DistingStateCopyWithImpl<$Res, _$DistingStateConnectedImpl>
    implements _$$DistingStateConnectedImplCopyWith<$Res> {
  __$$DistingStateConnectedImplCopyWithImpl(_$DistingStateConnectedImpl _value,
      $Res Function(_$DistingStateConnectedImpl) _then)
      : super(_value, _then);

  /// Create a copy of DistingState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? disting = null,
    Object? screenshot = freezed,
  }) {
    return _then(_$DistingStateConnectedImpl(
      disting: null == disting
          ? _value.disting
          : disting // ignore: cast_nullable_to_non_nullable
              as DistingMidiManager,
      screenshot: freezed == screenshot
          ? _value.screenshot
          : screenshot // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
    ));
  }
}

/// @nodoc

class _$DistingStateConnectedImpl
    with DiagnosticableTreeMixin
    implements DistingStateConnected {
  const _$DistingStateConnectedImpl({required this.disting, this.screenshot});

  @override
  final DistingMidiManager disting;
  @override
  final Uint8List? screenshot;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'DistingState.connected(disting: $disting, screenshot: $screenshot)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'DistingState.connected'))
      ..add(DiagnosticsProperty('disting', disting))
      ..add(DiagnosticsProperty('screenshot', screenshot));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DistingStateConnectedImpl &&
            (identical(other.disting, disting) || other.disting == disting) &&
            const DeepCollectionEquality()
                .equals(other.screenshot, screenshot));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, disting, const DeepCollectionEquality().hash(screenshot));

  /// Create a copy of DistingState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DistingStateConnectedImplCopyWith<_$DistingStateConnectedImpl>
      get copyWith => __$$DistingStateConnectedImplCopyWithImpl<
          _$DistingStateConnectedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Uint8List? screenshot) initial,
    required TResult Function(List<MidiDevice> inputDevices,
            List<MidiDevice> outputDevices, Uint8List? screenshot)
        selectDevice,
    required TResult Function(DistingMidiManager disting, Uint8List? screenshot)
        connected,
    required TResult Function(
            DistingMidiManager disting,
            String distingVersion,
            String presetName,
            List<AlgorithmInfo> algorithms,
            List<Slot> slots,
            List<String> unitStrings,
            Uint8List? screenshot,
            bool loading)
        synchronized,
  }) {
    return connected(disting, screenshot);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Uint8List? screenshot)? initial,
    TResult? Function(List<MidiDevice> inputDevices,
            List<MidiDevice> outputDevices, Uint8List? screenshot)?
        selectDevice,
    TResult? Function(DistingMidiManager disting, Uint8List? screenshot)?
        connected,
    TResult? Function(
            DistingMidiManager disting,
            String distingVersion,
            String presetName,
            List<AlgorithmInfo> algorithms,
            List<Slot> slots,
            List<String> unitStrings,
            Uint8List? screenshot,
            bool loading)?
        synchronized,
  }) {
    return connected?.call(disting, screenshot);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Uint8List? screenshot)? initial,
    TResult Function(List<MidiDevice> inputDevices,
            List<MidiDevice> outputDevices, Uint8List? screenshot)?
        selectDevice,
    TResult Function(DistingMidiManager disting, Uint8List? screenshot)?
        connected,
    TResult Function(
            DistingMidiManager disting,
            String distingVersion,
            String presetName,
            List<AlgorithmInfo> algorithms,
            List<Slot> slots,
            List<String> unitStrings,
            Uint8List? screenshot,
            bool loading)?
        synchronized,
    required TResult orElse(),
  }) {
    if (connected != null) {
      return connected(disting, screenshot);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DistingStateInitial value) initial,
    required TResult Function(DistingStateSelectDevice value) selectDevice,
    required TResult Function(DistingStateConnected value) connected,
    required TResult Function(DistingStateSynchronized value) synchronized,
  }) {
    return connected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DistingStateInitial value)? initial,
    TResult? Function(DistingStateSelectDevice value)? selectDevice,
    TResult? Function(DistingStateConnected value)? connected,
    TResult? Function(DistingStateSynchronized value)? synchronized,
  }) {
    return connected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DistingStateInitial value)? initial,
    TResult Function(DistingStateSelectDevice value)? selectDevice,
    TResult Function(DistingStateConnected value)? connected,
    TResult Function(DistingStateSynchronized value)? synchronized,
    required TResult orElse(),
  }) {
    if (connected != null) {
      return connected(this);
    }
    return orElse();
  }
}

abstract class DistingStateConnected implements DistingState {
  const factory DistingStateConnected(
      {required final DistingMidiManager disting,
      final Uint8List? screenshot}) = _$DistingStateConnectedImpl;

  DistingMidiManager get disting;
  @override
  Uint8List? get screenshot;

  /// Create a copy of DistingState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DistingStateConnectedImplCopyWith<_$DistingStateConnectedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DistingStateSynchronizedImplCopyWith<$Res>
    implements $DistingStateCopyWith<$Res> {
  factory _$$DistingStateSynchronizedImplCopyWith(
          _$DistingStateSynchronizedImpl value,
          $Res Function(_$DistingStateSynchronizedImpl) then) =
      __$$DistingStateSynchronizedImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {DistingMidiManager disting,
      String distingVersion,
      String presetName,
      List<AlgorithmInfo> algorithms,
      List<Slot> slots,
      List<String> unitStrings,
      Uint8List? screenshot,
      bool loading});
}

/// @nodoc
class __$$DistingStateSynchronizedImplCopyWithImpl<$Res>
    extends _$DistingStateCopyWithImpl<$Res, _$DistingStateSynchronizedImpl>
    implements _$$DistingStateSynchronizedImplCopyWith<$Res> {
  __$$DistingStateSynchronizedImplCopyWithImpl(
      _$DistingStateSynchronizedImpl _value,
      $Res Function(_$DistingStateSynchronizedImpl) _then)
      : super(_value, _then);

  /// Create a copy of DistingState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? disting = null,
    Object? distingVersion = null,
    Object? presetName = null,
    Object? algorithms = null,
    Object? slots = null,
    Object? unitStrings = null,
    Object? screenshot = freezed,
    Object? loading = null,
  }) {
    return _then(_$DistingStateSynchronizedImpl(
      disting: null == disting
          ? _value.disting
          : disting // ignore: cast_nullable_to_non_nullable
              as DistingMidiManager,
      distingVersion: null == distingVersion
          ? _value.distingVersion
          : distingVersion // ignore: cast_nullable_to_non_nullable
              as String,
      presetName: null == presetName
          ? _value.presetName
          : presetName // ignore: cast_nullable_to_non_nullable
              as String,
      algorithms: null == algorithms
          ? _value._algorithms
          : algorithms // ignore: cast_nullable_to_non_nullable
              as List<AlgorithmInfo>,
      slots: null == slots
          ? _value._slots
          : slots // ignore: cast_nullable_to_non_nullable
              as List<Slot>,
      unitStrings: null == unitStrings
          ? _value._unitStrings
          : unitStrings // ignore: cast_nullable_to_non_nullable
              as List<String>,
      screenshot: freezed == screenshot
          ? _value.screenshot
          : screenshot // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      loading: null == loading
          ? _value.loading
          : loading // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$DistingStateSynchronizedImpl
    with DiagnosticableTreeMixin
    implements DistingStateSynchronized {
  const _$DistingStateSynchronizedImpl(
      {required this.disting,
      required this.distingVersion,
      required this.presetName,
      required final List<AlgorithmInfo> algorithms,
      required final List<Slot> slots,
      required final List<String> unitStrings,
      this.screenshot,
      this.loading = false})
      : _algorithms = algorithms,
        _slots = slots,
        _unitStrings = unitStrings;

  @override
  final DistingMidiManager disting;
  @override
  final String distingVersion;
  @override
  final String presetName;
  final List<AlgorithmInfo> _algorithms;
  @override
  List<AlgorithmInfo> get algorithms {
    if (_algorithms is EqualUnmodifiableListView) return _algorithms;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_algorithms);
  }

  final List<Slot> _slots;
  @override
  List<Slot> get slots {
    if (_slots is EqualUnmodifiableListView) return _slots;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_slots);
  }

  final List<String> _unitStrings;
  @override
  List<String> get unitStrings {
    if (_unitStrings is EqualUnmodifiableListView) return _unitStrings;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_unitStrings);
  }

  @override
  final Uint8List? screenshot;
  @override
  @JsonKey()
  final bool loading;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'DistingState.synchronized(disting: $disting, distingVersion: $distingVersion, presetName: $presetName, algorithms: $algorithms, slots: $slots, unitStrings: $unitStrings, screenshot: $screenshot, loading: $loading)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'DistingState.synchronized'))
      ..add(DiagnosticsProperty('disting', disting))
      ..add(DiagnosticsProperty('distingVersion', distingVersion))
      ..add(DiagnosticsProperty('presetName', presetName))
      ..add(DiagnosticsProperty('algorithms', algorithms))
      ..add(DiagnosticsProperty('slots', slots))
      ..add(DiagnosticsProperty('unitStrings', unitStrings))
      ..add(DiagnosticsProperty('screenshot', screenshot))
      ..add(DiagnosticsProperty('loading', loading));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DistingStateSynchronizedImpl &&
            (identical(other.disting, disting) || other.disting == disting) &&
            (identical(other.distingVersion, distingVersion) ||
                other.distingVersion == distingVersion) &&
            (identical(other.presetName, presetName) ||
                other.presetName == presetName) &&
            const DeepCollectionEquality()
                .equals(other._algorithms, _algorithms) &&
            const DeepCollectionEquality().equals(other._slots, _slots) &&
            const DeepCollectionEquality()
                .equals(other._unitStrings, _unitStrings) &&
            const DeepCollectionEquality()
                .equals(other.screenshot, screenshot) &&
            (identical(other.loading, loading) || other.loading == loading));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      disting,
      distingVersion,
      presetName,
      const DeepCollectionEquality().hash(_algorithms),
      const DeepCollectionEquality().hash(_slots),
      const DeepCollectionEquality().hash(_unitStrings),
      const DeepCollectionEquality().hash(screenshot),
      loading);

  /// Create a copy of DistingState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DistingStateSynchronizedImplCopyWith<_$DistingStateSynchronizedImpl>
      get copyWith => __$$DistingStateSynchronizedImplCopyWithImpl<
          _$DistingStateSynchronizedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Uint8List? screenshot) initial,
    required TResult Function(List<MidiDevice> inputDevices,
            List<MidiDevice> outputDevices, Uint8List? screenshot)
        selectDevice,
    required TResult Function(DistingMidiManager disting, Uint8List? screenshot)
        connected,
    required TResult Function(
            DistingMidiManager disting,
            String distingVersion,
            String presetName,
            List<AlgorithmInfo> algorithms,
            List<Slot> slots,
            List<String> unitStrings,
            Uint8List? screenshot,
            bool loading)
        synchronized,
  }) {
    return synchronized(disting, distingVersion, presetName, algorithms, slots,
        unitStrings, screenshot, loading);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Uint8List? screenshot)? initial,
    TResult? Function(List<MidiDevice> inputDevices,
            List<MidiDevice> outputDevices, Uint8List? screenshot)?
        selectDevice,
    TResult? Function(DistingMidiManager disting, Uint8List? screenshot)?
        connected,
    TResult? Function(
            DistingMidiManager disting,
            String distingVersion,
            String presetName,
            List<AlgorithmInfo> algorithms,
            List<Slot> slots,
            List<String> unitStrings,
            Uint8List? screenshot,
            bool loading)?
        synchronized,
  }) {
    return synchronized?.call(disting, distingVersion, presetName, algorithms,
        slots, unitStrings, screenshot, loading);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Uint8List? screenshot)? initial,
    TResult Function(List<MidiDevice> inputDevices,
            List<MidiDevice> outputDevices, Uint8List? screenshot)?
        selectDevice,
    TResult Function(DistingMidiManager disting, Uint8List? screenshot)?
        connected,
    TResult Function(
            DistingMidiManager disting,
            String distingVersion,
            String presetName,
            List<AlgorithmInfo> algorithms,
            List<Slot> slots,
            List<String> unitStrings,
            Uint8List? screenshot,
            bool loading)?
        synchronized,
    required TResult orElse(),
  }) {
    if (synchronized != null) {
      return synchronized(disting, distingVersion, presetName, algorithms,
          slots, unitStrings, screenshot, loading);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DistingStateInitial value) initial,
    required TResult Function(DistingStateSelectDevice value) selectDevice,
    required TResult Function(DistingStateConnected value) connected,
    required TResult Function(DistingStateSynchronized value) synchronized,
  }) {
    return synchronized(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DistingStateInitial value)? initial,
    TResult? Function(DistingStateSelectDevice value)? selectDevice,
    TResult? Function(DistingStateConnected value)? connected,
    TResult? Function(DistingStateSynchronized value)? synchronized,
  }) {
    return synchronized?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DistingStateInitial value)? initial,
    TResult Function(DistingStateSelectDevice value)? selectDevice,
    TResult Function(DistingStateConnected value)? connected,
    TResult Function(DistingStateSynchronized value)? synchronized,
    required TResult orElse(),
  }) {
    if (synchronized != null) {
      return synchronized(this);
    }
    return orElse();
  }
}

abstract class DistingStateSynchronized implements DistingState {
  const factory DistingStateSynchronized(
      {required final DistingMidiManager disting,
      required final String distingVersion,
      required final String presetName,
      required final List<AlgorithmInfo> algorithms,
      required final List<Slot> slots,
      required final List<String> unitStrings,
      final Uint8List? screenshot,
      final bool loading}) = _$DistingStateSynchronizedImpl;

  DistingMidiManager get disting;
  String get distingVersion;
  String get presetName;
  List<AlgorithmInfo> get algorithms;
  List<Slot> get slots;
  List<String> get unitStrings;
  @override
  Uint8List? get screenshot;
  bool get loading;

  /// Create a copy of DistingState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DistingStateSynchronizedImplCopyWith<_$DistingStateSynchronizedImpl>
      get copyWith => throw _privateConstructorUsedError;
}
