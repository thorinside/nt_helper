import 'dart:convert'; // For jsonEncode/Decode

import 'package:drift/drift.dart';
import 'package:nt_helper/db/database.dart';
import 'package:nt_helper/db/tables.dart';
import 'package:nt_helper/domain/disting_nt_sysex.dart' hide ParameterPages;

part 'metadata_dao.g.dart'; // Generated by build_runner

@DriftAccessor(
  tables: [
    Algorithms,
    Specifications,
    Units,
    Parameters,
    ParameterEnums,
    ParameterPages,
    ParameterPageItems,
    ParameterOutputModeUsage,
    MetadataCache,
  ],
)
class MetadataDao extends DatabaseAccessor<AppDatabase>
    with _$MetadataDaoMixin {
  MetadataDao(super.db);

  // --- Insertion/Update Methods (Upserts) ---

  Future<void> upsertAlgorithms(List<AlgorithmEntry> entries) {
    return batch((batch) {
      batch.insertAll(algorithms, entries, mode: InsertMode.insertOrReplace);
    });
  }

  /// Update plugin file path for a specific algorithm by GUID
  Future<void> updateAlgorithmPluginFilePath(
    String guid,
    String? pluginFilePath,
  ) {
    return (update(algorithms)..where((a) => a.guid.equals(guid))).write(
      AlgorithmsCompanion(pluginFilePath: Value(pluginFilePath)),
    );
  }

  /// Get algorithm by GUID (useful for checking if algorithm exists)
  Future<AlgorithmEntry?> getAlgorithmByGuid(String guid) {
    return (select(
      algorithms,
    )..where((a) => a.guid.equals(guid))).getSingleOrNull();
  }

  /// Get plugin file paths for the specified GUIDs
  /// Returns a Map of GUID -> plugin file path for GUIDs that have plugin file paths
  Future<Map<String, String>> getPluginFilePathsByGuids(
    Set<String> guids,
  ) async {
    if (guids.isEmpty) return {};

    final query = select(
      algorithms,
    )..where((a) => a.guid.isIn(guids.toList()) & a.pluginFilePath.isNotNull());

    final results = await query.get();
    return {
      for (final algo in results)
        if (algo.pluginFilePath != null) algo.guid: algo.pluginFilePath!,
    };
  }

  Future<void> upsertSpecifications(List<SpecificationEntry> entries) {
    return batch((batch) {
      batch.insertAll(
        specifications,
        entries,
        mode: InsertMode.insertOrReplace,
      );
    });
  }

  Future<int> upsertUnit(String unitStr) {
    return into(units).insert(
      UnitsCompanion.insert(unitString: unitStr),
      mode: InsertMode.insertOrIgnore, // Ignore if already exists
      onConflict: DoNothing(), // Explicitly do nothing on conflict
    );
  }

  // Helper to get or insert a unit and return its ID
  Future<int?> getOrInsertUnitId(String? unitStr) async {
    if (unitStr == null || unitStr.isEmpty) return null;
    final existing = await (select(
      units,
    )..where((u) => u.unitString.equals(unitStr))).getSingleOrNull();
    if (existing != null) {
      return existing.id;
    }
    return await upsertUnit(unitStr);
  }

  Future<void> upsertParameters(List<ParameterEntry> entries) {
    return batch((batch) {
      batch.insertAll(parameters, entries, mode: InsertMode.insertOrReplace);
    });
  }

  Future<void> upsertParameterEnums(List<ParameterEnumEntry> entries) {
    return batch((batch) {
      batch.insertAll(
        parameterEnums,
        entries,
        mode: InsertMode.insertOrReplace,
      );
    });
  }

  Future<void> upsertParameterPages(List<ParameterPageEntry> entries) {
    return batch((batch) {
      batch.insertAll(
        parameterPages,
        entries,
        mode: InsertMode.insertOrReplace,
      );
    });
  }

  Future<void> upsertParameterPageItems(List<ParameterPageItemEntry> entries) {
    return batch((batch) {
      batch.insertAll(
        parameterPageItems,
        entries,
        mode: InsertMode.insertOrReplace,
      );
    });
  }

  // --- Deletion Methods (for clearing cache if needed) ---

  Future<void> clearAlgorithmMetadata(String algorithmGuid) async {
    await (delete(
      parameterPageItems,
    )..where((i) => i.algorithmGuid.equals(algorithmGuid))).go();
    await (delete(
      parameterPages,
    )..where((p) => p.algorithmGuid.equals(algorithmGuid))).go();
    await (delete(
      parameterEnums,
    )..where((e) => e.algorithmGuid.equals(algorithmGuid))).go();
    await (delete(
      parameters,
    )..where((p) => p.algorithmGuid.equals(algorithmGuid))).go();
    await (delete(
      specifications,
    )..where((s) => s.algorithmGuid.equals(algorithmGuid))).go();
    // Don't delete the algorithm entry itself here, assume it might be referenced elsewhere (presets)
    // If you need to fully remove an algorithm, you'd delete from Algorithms table last.
  }

  Future<void> clearAllMetadata() async {
    // Delete in reverse order of dependency
    await delete(parameterPageItems).go();
    await delete(parameterPages).go();
    await delete(parameterEnums).go();
    await delete(parameters).go();
    await delete(units).go(); // Units might be shared, consider if needed
    await delete(specifications).go();
    await delete(algorithms).go();
  }

  // --- Methods for MetadataCache ---

  static const String _orderedUnitsKey = 'unit_strings_ordered_list';

  /// Saves the ordered list of unit strings retrieved during sync.
  Future<void> saveOrderedUnitStrings(List<String> unitStrings) {
    final jsonString = jsonEncode(unitStrings);
    final entry = MetadataCacheCompanion.insert(
      cacheKey: _orderedUnitsKey,
      cacheValue: jsonString,
    );
    return into(metadataCache).insert(entry, mode: InsertMode.insertOrReplace);
  }

  /// Retrieves the ordered list of unit strings saved during the last sync.
  /// Returns null if the list hasn't been saved yet.
  Future<List<String>?> getOrderedUnitStrings() async {
    final entry = await (select(
      metadataCache,
    )..where((tbl) => tbl.cacheKey.equals(_orderedUnitsKey))).getSingleOrNull();

    if (entry != null) {
      try {
        final decoded = jsonDecode(entry.cacheValue);
        if (decoded is List) {
          return decoded.cast<String>();
        }
      } catch (e) {
        // Handle potential JSON decoding errors
        return null;
      }
    }
    return null;
  }

  // --- Algorithm Info Cache ---

  static const String _algorithmInfoCacheKey = 'algorithm_info_cache';

  /// Cache data structure for algorithm info
  /// Contains: algorithms list, numAlgorithms count, and timestamp
  Future<void> saveAlgorithmInfoCache(
    List<AlgorithmInfo> algorithms,
    int numAlgorithms,
  ) async {
    final cacheData = {
      'algorithms': algorithms.map((a) => a.toJson()).toList(),
      'numAlgorithms': numAlgorithms,
      'timestamp': DateTime.now().toIso8601String(),
    };
    final jsonString = jsonEncode(cacheData);
    final entry = MetadataCacheCompanion.insert(
      cacheKey: _algorithmInfoCacheKey,
      cacheValue: jsonString,
    );
    await into(metadataCache).insert(entry, mode: InsertMode.insertOrReplace);
  }

  /// Retrieves cached algorithm info if valid (fresh and matching numAlgorithms).
  /// Returns null if cache is invalid, expired, or doesn't exist.
  /// [cacheFreshnessDays] specifies how many days the cache is considered fresh.
  Future<List<AlgorithmInfo>?> getAlgorithmInfoCache(
    int currentNumAlgorithms, {
    int cacheFreshnessDays = 2,
  }) async {
    final entry = await (select(metadataCache)
          ..where((tbl) => tbl.cacheKey.equals(_algorithmInfoCacheKey)))
        .getSingleOrNull();

    if (entry == null) return null;

    try {
      final decoded = jsonDecode(entry.cacheValue) as Map<String, dynamic>;
      final cachedNumAlgorithms = decoded['numAlgorithms'] as int?;
      final timestampStr = decoded['timestamp'] as String?;
      final algorithmsJson = decoded['algorithms'] as List?;

      // Validate cache
      if (cachedNumAlgorithms == null ||
          timestampStr == null ||
          algorithmsJson == null) {
        return null;
      }

      // Check if numAlgorithms matches
      if (cachedNumAlgorithms != currentNumAlgorithms) {
        return null;
      }

      // Check freshness
      final timestamp = DateTime.tryParse(timestampStr);
      if (timestamp == null) return null;

      final age = DateTime.now().difference(timestamp);
      if (age > Duration(days: cacheFreshnessDays)) {
        return null;
      }

      // Parse and return algorithms
      return algorithmsJson
          .map((json) => AlgorithmInfo.fromJson(json as Map<String, dynamic>))
          .toList();
    } catch (e) {
      // JSON parsing error - cache is corrupted
      return null;
    }
  }

  /// Invalidates the algorithm info cache (call after plugin install or rescan).
  Future<void> invalidateAlgorithmInfoCache() async {
    await (delete(metadataCache)
          ..where((tbl) => tbl.cacheKey.equals(_algorithmInfoCacheKey)))
        .go();
  }

  /// Checks if algorithm info cache exists and is valid without loading the full data.
  /// [cacheFreshnessDays] specifies how many days the cache is considered fresh.
  Future<bool> isAlgorithmInfoCacheValid(
    int currentNumAlgorithms, {
    int cacheFreshnessDays = 2,
  }) async {
    final entry = await (select(metadataCache)
          ..where((tbl) => tbl.cacheKey.equals(_algorithmInfoCacheKey)))
        .getSingleOrNull();

    if (entry == null) return false;

    try {
      final decoded = jsonDecode(entry.cacheValue) as Map<String, dynamic>;
      final cachedNumAlgorithms = decoded['numAlgorithms'] as int?;
      final timestampStr = decoded['timestamp'] as String?;

      if (cachedNumAlgorithms == null || timestampStr == null) return false;
      if (cachedNumAlgorithms != currentNumAlgorithms) return false;

      final timestamp = DateTime.tryParse(timestampStr);
      if (timestamp == null) return false;

      final age = DateTime.now().difference(timestamp);
      return age <= Duration(days: cacheFreshnessDays);
    } catch (e) {
      return false;
    }
  }

  // --- Query Methods ---

  Future<Map<String, int>> getAlgorithmParameterCounts() async {
    // Define the count expression
    final countExp = parameters.parameterNumber.count();

    final query = select(parameters).addColumns([
      parameters.algorithmGuid,
      countExp, // Use the count expression here
    ]);
    query.groupBy([parameters.algorithmGuid]); // Group by algorithm

    final results = await query.get();

    return {
      for (var row in results)
        // Read the GUID and the calculated count expression
        row.read(parameters.algorithmGuid)!: row.read(countExp) ?? 0,
    };
  }

  Future<List<AlgorithmEntry>> getAllAlgorithms() {
    return (select(
      algorithms,
    )..orderBy([(a) => OrderingTerm.asc(a.name)])).get();
  }

  Future<List<AlgorithmEntry>> getAllAlgorithmsWithParameters() async {
    final subQuery = selectOnly(parameters, distinct: true)
      ..addColumns([parameters.algorithmGuid]);

    final guidsWithParams = await subQuery
        .map((row) => row.read(parameters.algorithmGuid)!)
        .get();

    // If no algorithms have parameters, return empty list
    if (guidsWithParams.isEmpty) {
      return [];
    }

    final mainQuery = select(algorithms)
      ..where(
        (a) => a.guid.isIn(guidsWithParams),
      ) // Filter by the list of GUIDs
      ..orderBy([(a) => OrderingTerm.asc(a.name)]); // Order the result

    return mainQuery.get();
  }

  Stream<List<AlgorithmEntry>> watchAllAlgorithms() {
    return (select(
      algorithms,
    )..orderBy([(a) => OrderingTerm.asc(a.name)])).watch();
  }

  Future<List<UnitEntry>> getAllUnits() => select(units).get();

  // --- Bulk Retrieval Methods for Full Export ---

  Future<List<SpecificationEntry>> getAllSpecifications() {
    return (select(specifications)
          ..orderBy([(s) => OrderingTerm.asc(s.algorithmGuid)])
          ..orderBy([(s) => OrderingTerm.asc(s.specIndex)]))
        .get();
  }

  Future<List<ParameterEntry>> getAllParameters() {
    return (select(parameters)
          ..orderBy([(p) => OrderingTerm.asc(p.algorithmGuid)])
          ..orderBy([(p) => OrderingTerm.asc(p.parameterNumber)]))
        .get();
  }

  Future<List<ParameterEnumEntry>> getAllParameterEnums() {
    return (select(parameterEnums)
          ..orderBy([(e) => OrderingTerm.asc(e.algorithmGuid)])
          ..orderBy([(e) => OrderingTerm.asc(e.parameterNumber)])
          ..orderBy([(e) => OrderingTerm.asc(e.enumIndex)]))
        .get();
  }

  Future<List<ParameterPageEntry>> getAllParameterPages() {
    return (select(parameterPages)
          ..orderBy([(p) => OrderingTerm.asc(p.algorithmGuid)])
          ..orderBy([(p) => OrderingTerm.asc(p.pageIndex)]))
        .get();
  }

  Future<List<ParameterPageItemEntry>> getAllParameterPageItems() {
    return (select(parameterPageItems)
          ..orderBy([(i) => OrderingTerm.asc(i.algorithmGuid)])
          ..orderBy([(i) => OrderingTerm.asc(i.pageIndex)])
          ..orderBy([(i) => OrderingTerm.asc(i.parameterNumber)]))
        .get();
  }

  /// Get output mode usage data for a specific parameter.
  /// Returns a list of affected output numbers.
  /// Returns null if no data exists for this parameter.
  Future<List<int>?> getOutputModeUsage(
    String algorithmGuid,
    int parameterNumber,
  ) async {
    final entry = await (select(parameterOutputModeUsage)
          ..where((t) =>
              t.algorithmGuid.equals(algorithmGuid) &
              t.parameterNumber.equals(parameterNumber)))
        .getSingleOrNull();

    // The converter automatically handles JSON deserialization
    // affectedOutputNumbers is already a List<int> in the Dart model
    return entry?.affectedOutputNumbers;
  }

  /// Get all output mode usage entries for bulk export.
  Future<List<ParameterOutputModeUsageEntry>> getAllOutputModeUsage() {
    return (select(parameterOutputModeUsage)
          ..orderBy([(t) => OrderingTerm.asc(t.algorithmGuid)])
          ..orderBy([(t) => OrderingTerm.asc(t.parameterNumber)]))
        .get();
  }

  /// Get all output mode usage for a specific algorithm.
  /// Returns a map from mode parameter number to list of affected output numbers.
  Future<Map<int, List<int>>> getOutputModeUsageForAlgorithm(
    String algorithmGuid,
  ) async {
    final entries = await (select(parameterOutputModeUsage)
          ..where((t) => t.algorithmGuid.equals(algorithmGuid)))
        .get();

    final result = <int, List<int>>{};
    for (final entry in entries) {
      result[entry.parameterNumber] = entry.affectedOutputNumbers;
    }
    return result;
  }

  /// Upsert output mode usage entries.
  Future<void> upsertOutputModeUsage(
    List<ParameterOutputModeUsageEntry> entries,
  ) {
    return batch((batch) {
      batch.insertAll(
        parameterOutputModeUsage,
        entries,
        mode: InsertMode.insertOrReplace,
      );
    });
  }

  Future<List<MetadataCacheEntry>> getMetadataCacheEntries() {
    return select(metadataCache).get();
  }

  // Example: Get full details for one algorithm
  Future<FullAlgorithmDetails?> getFullAlgorithmDetails(String guid) async {
    final algoQuery = select(algorithms)..where((a) => a.guid.equals(guid));
    final algo = await algoQuery.getSingleOrNull();
    if (algo == null) return null;

    // --- Fetch all necessary data in parallel ---

    // Parameters with Units
    final paramsBase = select(
      parameters,
    ).join([leftOuterJoin(units, units.id.equalsExp(parameters.unitId))]);
    paramsBase.where(parameters.algorithmGuid.equals(guid));
    paramsBase.orderBy([OrderingTerm.asc(parameters.parameterNumber)]);

    // Specifications
    final specsBase = select(specifications)
      ..where((s) => s.algorithmGuid.equals(guid))
      ..orderBy([(s) => OrderingTerm.asc(s.specIndex)]);

    // Parameter Pages
    final pagesBase = select(parameterPages)
      ..where((p) => p.algorithmGuid.equals(guid))
      ..orderBy([(p) => OrderingTerm.asc(p.pageIndex)]);

    // Page Items (linking parameters to pages)
    final pageItemsBase = select(parameterPageItems)
      ..where((i) => i.algorithmGuid.equals(guid));

    // Enums
    final enumsBase = select(parameterEnums)
      ..where((e) => e.algorithmGuid.equals(guid));

    final results = await Future.wait([
      paramsBase.get(),
      specsBase.get(),
      pagesBase.get(), // Fetches ParameterPageEntry
      pageItemsBase.get(), // Fetches ParameterPageItemEntry
      enumsBase.get(),
    ]);

    // --- Process fetched data ---

    final paramResults = results[0] as List<TypedResult>;
    final specs = results[1] as List<SpecificationEntry>;
    final pages = results[2] as List<ParameterPageEntry>;
    final pageItems = results[3] as List<ParameterPageItemEntry>;
    final enums = results[4] as List<ParameterEnumEntry>;

    // Build lookup maps for efficiency
    final pageIndexToName = {for (var p in pages) p.pageIndex: p.name};
    final paramNumToPageIndex = {
      for (var i in pageItems) i.parameterNumber: i.pageIndex,
    };

    // Create ParameterWithUnit list, now including pageName
    final paramsWithUnits = paramResults.map((row) {
      final param = row.readTable(parameters);
      final unit = row.readTableOrNull(units);
      final pageIndex = paramNumToPageIndex[param.parameterNumber];
      final pageName = pageIndex != null ? pageIndexToName[pageIndex] : null;
      return ParameterWithUnit(
        param,
        unit?.unitString,
        pageName,
      ); // Pass pageName
    }).toList();

    // Organize page items and enums for easier access
    final pageMap = <int, List<int>>{}; // pageIndex -> List<parameterNumber>
    for (final item in pageItems) {
      (pageMap[item.pageIndex] ??= []).add(item.parameterNumber);
    }

    final enumMap =
        <int, List<String>>{}; // parameterNumber -> List<enumString>
    for (final enumEntry in enums) {
      (enumMap[enumEntry.parameterNumber] ??= []).add(enumEntry.enumString);
    }

    return FullAlgorithmDetails(
      algorithm: algo,
      specifications: specs,
      parameters: paramsWithUnits,
      parameterPages: pages
          .map(
            (p) => ParameterPageWithItems(
              page: p,
              parameterNumbers: pageMap[p.pageIndex] ?? [],
            ),
          )
          .toList(),
      enums: enumMap,
    );
  }

  /// Checks if there are any algorithms stored in the database.
  Future<bool> hasCachedAlgorithms() async {
    final query = selectOnly(algorithms)..addColumns([algorithms.guid.count()]);
    final result = await query.getSingleOrNull();
    final count = result?.read(algorithms.guid.count()) ?? 0;
    return count > 0;
  }
}

// Helper classes for combined query results
class ParameterWithUnit {
  final ParameterEntry parameter;
  final String? unitString;
  final String? pageName;

  ParameterWithUnit(this.parameter, this.unitString, this.pageName);
}

class ParameterPageWithItems {
  final ParameterPageEntry page;
  final List<int> parameterNumbers;
  ParameterPageWithItems({required this.page, required this.parameterNumbers});
}

class FullAlgorithmDetails {
  final AlgorithmEntry algorithm;
  final List<SpecificationEntry> specifications;
  final List<ParameterWithUnit> parameters;
  final List<ParameterPageWithItems> parameterPages;
  final Map<int, List<String>> enums; // parameterNumber -> List<enumString>

  FullAlgorithmDetails({
    required this.algorithm,
    required this.specifications,
    required this.parameters,
    required this.parameterPages,
    required this.enums,
  });
}
