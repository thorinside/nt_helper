import 'package:drift/drift.dart';
import 'package:nt_helper/db/database.dart';
import 'package:nt_helper/db/tables.dart';

part 'metadata_dao.g.dart'; // Generated by build_runner

@DriftAccessor(tables: [
  Algorithms,
  Specifications,
  Units,
  Parameters,
  ParameterEnums,
  ParameterPages,
  ParameterPageItems,
])
class MetadataDao extends DatabaseAccessor<AppDatabase>
    with _$MetadataDaoMixin {
  MetadataDao(AppDatabase db) : super(db);

  // --- Insertion/Update Methods (Upserts) ---

  Future<void> upsertAlgorithms(List<AlgorithmEntry> entries) {
    return batch((batch) {
      batch.insertAll(algorithms, entries, mode: InsertMode.insertOrReplace);
    });
  }

  Future<void> upsertSpecifications(List<SpecificationEntry> entries) {
    return batch((batch) {
      batch.insertAll(specifications, entries,
          mode: InsertMode.insertOrReplace);
    });
  }

  Future<int> upsertUnit(String unitStr) {
    return into(units).insert(
      UnitsCompanion.insert(unitString: unitStr),
      mode: InsertMode.insertOrIgnore, // Ignore if already exists
      onConflict: DoNothing(), // Explicitly do nothing on conflict
    );
  }

  // Helper to get or insert a unit and return its ID
  Future<int?> getOrInsertUnitId(String? unitStr) async {
    if (unitStr == null || unitStr.isEmpty) return null;
    final existing = await (select(units)
          ..where((u) => u.unitString.equals(unitStr)))
        .getSingleOrNull();
    if (existing != null) {
      return existing.id;
    }
    return await upsertUnit(unitStr);
  }

  Future<void> upsertParameters(List<ParameterEntry> entries) {
    return batch((batch) {
      batch.insertAll(parameters, entries, mode: InsertMode.insertOrReplace);
    });
  }

  Future<void> upsertParameterEnums(List<ParameterEnumEntry> entries) {
    return batch((batch) {
      batch.insertAll(parameterEnums, entries,
          mode: InsertMode.insertOrReplace);
    });
  }

  Future<void> upsertParameterPages(List<ParameterPageEntry> entries) {
    return batch((batch) {
      batch.insertAll(parameterPages, entries,
          mode: InsertMode.insertOrReplace);
    });
  }

  Future<void> upsertParameterPageItems(List<ParameterPageItemEntry> entries) {
    return batch((batch) {
      batch.insertAll(parameterPageItems, entries,
          mode: InsertMode.insertOrReplace);
    });
  }

  // --- Deletion Methods (for clearing cache if needed) ---

  Future<void> clearAlgorithmMetadata(String algorithmGuid) async {
    await (delete(parameterPageItems)
          ..where((i) => i.algorithmGuid.equals(algorithmGuid)))
        .go();
    await (delete(parameterPages)
          ..where((p) => p.algorithmGuid.equals(algorithmGuid)))
        .go();
    await (delete(parameterEnums)
          ..where((e) => e.algorithmGuid.equals(algorithmGuid)))
        .go();
    await (delete(parameters)
          ..where((p) => p.algorithmGuid.equals(algorithmGuid)))
        .go();
    await (delete(specifications)
          ..where((s) => s.algorithmGuid.equals(algorithmGuid)))
        .go();
    // Don't delete the algorithm entry itself here, assume it might be referenced elsewhere (presets)
    // If you need to fully remove an algorithm, you'd delete from Algorithms table last.
  }

  Future<void> clearAllMetadata() async {
    // Delete in reverse order of dependency
    await delete(parameterPageItems).go();
    await delete(parameterPages).go();
    await delete(parameterEnums).go();
    await delete(parameters).go();
    await delete(units).go(); // Units might be shared, consider if needed
    await delete(specifications).go();
    await delete(algorithms).go();
  }

  // --- Query Methods ---

  Stream<List<AlgorithmEntry>> watchAllAlgorithms() =>
      select(algorithms).watch();

  Future<List<UnitEntry>> getAllUnits() => select(units).get();

  // Example: Get full details for one algorithm
  Future<FullAlgorithmDetails?> getFullAlgorithmDetails(String guid) async {
    final algoQuery = select(algorithms)..where((a) => a.guid.equals(guid));
    final algo = await algoQuery.getSingleOrNull();
    if (algo == null) return null;

    // Parameters
    final paramsBase = select(parameters).join([
      leftOuterJoin(units, units.id.equalsExp(parameters.unitId)),
    ]);
    paramsBase.where(parameters.algorithmGuid.equals(guid));
    paramsBase.orderBy([OrderingTerm.asc(parameters.parameterNumber)]);

    // Specifications
    final specsBase = select(specifications);
    specsBase.where((s) => s.algorithmGuid.equals(guid));
    specsBase.orderBy([(s) => OrderingTerm.asc(s.specIndex)]);

    // Pages
    final pagesBase = select(parameterPages);
    pagesBase.where((p) => p.algorithmGuid.equals(guid));
    pagesBase.orderBy([(p) => OrderingTerm.asc(p.pageIndex)]);

    // Page Items
    final pageItemsBase = select(parameterPageItems)
      ..where((i) => i.algorithmGuid.equals(guid));

    // Enums
    final enumsBase = select(parameterEnums)
      ..where((e) => e.algorithmGuid.equals(guid));

    // Fetch in parallel
    final results = await Future.wait([
      paramsBase.get(),
      specsBase.get(),
      pagesBase.get(),
      pageItemsBase.get(),
      enumsBase.get(),
    ]);

    final paramsWithUnits = (results[0] as List<TypedResult>).map((row) {
      final param = row.readTable(parameters);
      final unit = row.readTableOrNull(units);
      return ParameterWithUnit(param, unit?.unitString);
    }).toList();

    final specs = results[1] as List<SpecificationEntry>;
    final pages = results[2] as List<ParameterPageEntry>;
    final pageItems = results[3] as List<ParameterPageItemEntry>;
    final enums = results[4] as List<ParameterEnumEntry>;

    // Organize page items and enums for easier access
    final pageMap = <int, List<int>>{}; // pageIndex -> List<parameterNumber>
    for (final item in pageItems) {
      (pageMap[item.pageIndex] ??= []).add(item.parameterNumber);
    }

    final enumMap =
        <int, List<String>>{}; // parameterNumber -> List<enumString>
    for (final enumEntry in enums) {
      (enumMap[enumEntry.parameterNumber] ??= []).add(enumEntry.enumString);
    }
    // Ensure correct order if enumIndex matters
    enumMap.forEach((key, valueList) {
      // If you stored enumIndex with the ParameterEnumEntry, sort here.
      // Assuming the fetch order was correct or index isn't critical for this structure.
    });

    return FullAlgorithmDetails(
      algorithm: algo,
      specifications: specs,
      parameters: paramsWithUnits,
      parameterPages: pages
          .map((p) => ParameterPageWithItems(
                page: p,
                parameterNumbers: pageMap[p.pageIndex] ?? [],
              ))
          .toList(),
      enums: enumMap,
    );
  }
}

// Helper classes for combined query results
class ParameterWithUnit {
  final ParameterEntry parameter;
  final String? unitString;
  ParameterWithUnit(this.parameter, this.unitString);
}

class ParameterPageWithItems {
  final ParameterPageEntry page;
  final List<int> parameterNumbers;
  ParameterPageWithItems({required this.page, required this.parameterNumbers});
}

class FullAlgorithmDetails {
  final AlgorithmEntry algorithm;
  final List<SpecificationEntry> specifications;
  final List<ParameterWithUnit> parameters;
  final List<ParameterPageWithItems> parameterPages;
  final Map<int, List<String>> enums; // parameterNumber -> List<enumString>

  FullAlgorithmDetails({
    required this.algorithm,
    required this.specifications,
    required this.parameters,
    required this.parameterPages,
    required this.enums,
  });
}
