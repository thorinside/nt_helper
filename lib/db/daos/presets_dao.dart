import 'package:drift/drift.dart';
import 'package:nt_helper/db/database.dart';
import 'package:nt_helper/db/tables.dart';
import 'package:nt_helper/models/packed_mapping_data.dart'; // For PresetMappingEntry

part 'presets_dao.g.dart'; // Generated by build_runner

@DriftAccessor(tables: [
  Presets,
  PresetSlots,
  PresetParameterValues,
  PresetMappings,
  PresetRoutings,
  // Also need Algorithms to get GUIDs/Names if not passing full objects
  Algorithms,
])
class PresetsDao extends DatabaseAccessor<AppDatabase> with _$PresetsDaoMixin {
  PresetsDao(AppDatabase db) : super(db);

  // --- Query Methods ---

  Stream<List<PresetEntry>> watchAllPresets() {
    return (select(presets)..orderBy([(p) => OrderingTerm.asc(p.name)]))
        .watch();
  }

  Future<List<PresetEntry>> getAllPresets() {
    return (select(presets)..orderBy([(p) => OrderingTerm.asc(p.name)])).get();
  }

  Future<PresetEntry?> getPresetByName(String name) {
    return (select(presets)..where((p) => p.name.equals(name)))
        .getSingleOrNull();
  }

  Future<PresetEntry?> getPresetById(int id) {
    return (select(presets)..where((p) => p.id.equals(id))).getSingleOrNull();
  }

  Future<FullPresetDetails?> getFullPresetDetails(int presetId) async {
    final preset = await getPresetById(presetId);
    if (preset == null) return null;

    // Fetch slots associated with the preset, joining with Algorithms for names/guids
    final slotQuery = select(presetSlots).join([
      innerJoin(
          algorithms, algorithms.guid.equalsExp(presetSlots.algorithmGuid))
    ])
      ..where(presetSlots.presetId.equals(presetId))
      ..orderBy([OrderingTerm.asc(presetSlots.slotIndex)]);

    final slotResults = await slotQuery.get();
    if (slotResults.isEmpty) {
      // Preset exists but has no slots (valid case)
      return FullPresetDetails(preset: preset, slots: []);
    }

    final slotIds =
        slotResults.map((row) => row.readTable(presetSlots).id).toList();

    // Fetch values, mappings, and routings for all slots in parallel
    final valuesQuery = select(presetParameterValues)
      ..where((v) => v.presetSlotId.isIn(slotIds));
    final mappingsQuery = select(presetMappings)
      ..where((m) => m.presetSlotId.isIn(slotIds));
    final routingsQuery = select(presetRoutings)
      ..where((r) => r.presetSlotId.isIn(slotIds));

    final results = await Future.wait([
      valuesQuery.get(),
      mappingsQuery.get(),
      routingsQuery.get(),
    ]);

    final values = results[0] as List<PresetParameterValueEntry>;
    final mappings = results[1] as List<PresetMappingEntry>;
    final routings = results[2] as List<PresetRoutingEntry>;

    // Organize data by slot ID
    final valuesMap = <int, Map<int, int>>{}; // slotId -> {paramNum: value}
    for (final v in values) {
      (valuesMap[v.presetSlotId] ??= {})[v.parameterNumber] = v.value;
    }

    final mappingsMap = <int,
        Map<int, PackedMappingData>>{}; // slotId -> {paramNum: mappingData}
    for (final m in mappings) {
      (mappingsMap[m.presetSlotId] ??= {})[m.parameterNumber] = m.packedData;
    }

    final routingsMap = <int, List<int>>{}; // slotId -> routingInfo
    for (final r in routings) {
      routingsMap[r.presetSlotId] = r.routingInfoJson;
    }

    // Construct the final FullPresetDetails object
    final fullSlots = slotResults.map((row) {
      final slot = row.readTable(presetSlots);
      final algo = row.readTable(algorithms);
      final slotId = slot.id;
      return FullPresetSlot(
        slot: slot,
        algorithm: algo,
        parameterValues: valuesMap[slotId] ?? {},
        mappings: mappingsMap[slotId] ?? {},
        routingInfo: routingsMap[slotId] ?? [],
      );
    }).toList();

    return FullPresetDetails(preset: preset, slots: fullSlots);
  }

  // --- Insertion/Update Methods ---

  // Saves a complete preset. Uses a transaction.
  // If a preset with the same name exists, it updates it; otherwise, it inserts a new one.
  Future<int> saveFullPreset(FullPresetDetails presetData) async {
    return transaction(() async {
      final presetName = presetData.preset.name;
      int presetId;

      // 1. Look up existing preset by name
      final existingPreset = await getPresetByName(presetName);

      if (existingPreset != null) {
        // --- UPDATE existing preset ---
        presetId = existingPreset.id;
        // Update the existing preset entry (e.g., lastModified)
        await (update(presets)..where((p) => p.id.equals(presetId))).write(
          PresetsCompanion(
            // name: Value(presetName), // Name shouldn't change here
            lastModified: Value(DateTime.now()),
          ),
        );
        print(
            "[PresetsDao] Updating existing preset ID: $presetId, Name: '$presetName'");
      } else {
        // --- INSERT new preset ---
        final presetCompanion = presetData.preset.toCompanion(false).copyWith(
              id: const Value.absent(), // Explicitly ignore ID for insert
              lastModified:
                  Value(DateTime.now()), // Ensure lastModified is updated
            );
        presetId = await into(presets).insert(presetCompanion,
            mode: InsertMode.insert); // Force insert for new name
        print(
            "[PresetsDao] Inserting new preset. Assigned ID: $presetId, Name: '$presetName'");
      }

      // 2. Clear existing related data for the target preset ID
      //    (Necessary for both insert and update to ensure clean state)
      final existingSlots = await (select(presetSlots)
            ..where((s) => s.presetId.equals(presetId)))
          .get();
      final existingSlotIds = existingSlots.map((s) => s.id).toList();
      if (existingSlotIds.isNotEmpty) {
        await (delete(presetParameterValues)
              ..where((v) => v.presetSlotId.isIn(existingSlotIds)))
            .go();
        await (delete(presetMappings)
              ..where((m) => m.presetSlotId.isIn(existingSlotIds)))
            .go();
        await (delete(presetRoutings)
              ..where((r) => r.presetSlotId.isIn(existingSlotIds)))
            .go();
        await (delete(presetSlots)..where((s) => s.presetId.equals(presetId)))
            .go();
      }

      // 3. Insert new slots and their associated data
      for (final fullSlot in presetData.slots) {
        // 3a. Insert PresetSlot
        final slotCompanion = PresetSlotsCompanion.insert(
          presetId: presetId,
          slotIndex: fullSlot.slot.slotIndex,
          algorithmGuid: fullSlot.algorithm.guid,
          customName:
              Value(fullSlot.slot.customName), // Use Value() for nullables
        );
        final slotId = await into(presetSlots).insert(slotCompanion);

        // 3b. Insert Parameter Values
        if (fullSlot.parameterValues.isNotEmpty) {
          final valueCompanions = fullSlot.parameterValues.entries
              .map((entry) => PresetParameterValuesCompanion.insert(
                    presetSlotId: slotId,
                    parameterNumber: entry.key,
                    value: entry.value,
                  ))
              .toList();
          await batch(
              (b) => b.insertAll(presetParameterValues, valueCompanions));
        }

        // 3c. Insert Mappings
        if (fullSlot.mappings.isNotEmpty) {
          final mappingCompanions = fullSlot.mappings.entries
              .map((entry) => PresetMappingsCompanion.insert(
                    presetSlotId: slotId,
                    parameterNumber: entry.key,
                    packedData:
                        entry.value, // Assumes type converter handles this
                  ))
              .toList();
          await batch((b) => b.insertAll(presetMappings, mappingCompanions));
        }

        // 3d. Insert Routing
        if (fullSlot.routingInfo.isNotEmpty) {
          final routingCompanion = PresetRoutingsCompanion.insert(
            presetSlotId: Value(slotId),
            routingInfoJson: fullSlot.routingInfo,
          );
          await into(presetRoutings).insert(routingCompanion);
        }
      }
      return presetId;
    });
  }

  Future<int> updatePresetName(int presetId, String newName) {
    return (update(presets)..where((p) => p.id.equals(presetId))).write(
      PresetsCompanion(
        name: Value(newName),
        lastModified: Value(DateTime.now()),
      ),
    );
  }

  // --- Deletion Methods ---

  Future<void> deletePreset(int presetId) async {
    return transaction(() async {
      // Similar to save, delete dependencies first
      final existingSlots = await (select(presetSlots)
            ..where((s) => s.presetId.equals(presetId)))
          .get();
      final existingSlotIds = existingSlots.map((s) => s.id).toList();
      if (existingSlotIds.isNotEmpty) {
        await (delete(presetParameterValues)
              ..where((v) => v.presetSlotId.isIn(existingSlotIds)))
            .go();
        await (delete(presetMappings)
              ..where((m) => m.presetSlotId.isIn(existingSlotIds)))
            .go();
        await (delete(presetRoutings)
              ..where((r) => r.presetSlotId.isIn(existingSlotIds)))
            .go();
        await (delete(presetSlots)..where((s) => s.presetId.equals(presetId)))
            .go();
      }
      // Finally, delete the preset itself
      await (delete(presets)..where((p) => p.id.equals(presetId))).go();
    });
  }
}

// --- Helper classes for returning structured preset data ---

class FullPresetSlot {
  final PresetSlotEntry slot;
  final AlgorithmEntry algorithm; // Algorithm info for this slot
  final Map<int, int> parameterValues; // parameterNumber -> value
  final Map<int, PackedMappingData> mappings; // parameterNumber -> mappingData
  final List<int> routingInfo;

  FullPresetSlot({
    required this.slot,
    required this.algorithm,
    required this.parameterValues,
    required this.mappings,
    required this.routingInfo,
  });
}

class FullPresetDetails {
  final PresetEntry preset;
  final List<FullPresetSlot> slots;

  FullPresetDetails({
    required this.preset,
    required this.slots,
  });

  // Optional: Add a method to convert back to Companion for saving/updating
  PresetsCompanion toCompanion(bool ignoreId) {
    return PresetsCompanion(
        id: ignoreId ? const Value.absent() : Value(preset.id),
        name: Value(preset.name),
        lastModified:
            Value(preset.lastModified) // Or update time? Value(DateTime.now())
        );
  }
}
