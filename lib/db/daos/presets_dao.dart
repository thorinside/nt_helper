import 'package:drift/drift.dart';
import 'package:nt_helper/db/database.dart';
import 'package:nt_helper/db/tables.dart';
import 'package:nt_helper/models/packed_mapping_data.dart'; // For PresetMappingEntry
import 'package:collection/collection.dart'; // For groupBy, mapIndexed

part 'presets_dao.g.dart'; // Generated by build_runner

// --- Data Transfer Objects (DTOs) ---

/// Represents a complete preset with all its slots and associated data.
class FullPresetDetails {
  final PresetEntry preset;
  final List<FullPresetSlot> slots; // Sorted by slotIndex

  FullPresetDetails({required this.preset, required this.slots});
}

/// Represents a single slot within a preset, including its algorithm,
/// parameter values, mappings, routing info, and string values.
class FullPresetSlot {
  final PresetSlotEntry
  slot; // Contains slotIndex, customName, presetId, algorithmGuid
  final AlgorithmEntry algorithm; // Base algorithm metadata
  final Map<int, int> parameterValues; // paramNum -> value
  final Map<int, String> parameterStringValues; // paramNum -> stringValue
  final Map<int, PackedMappingData> mappings; // paramNum -> mappingData

  FullPresetSlot({
    required this.slot,
    required this.algorithm,
    required this.parameterValues,
    required this.parameterStringValues,
    required this.mappings,
  });
}

// --- DAO Definition ---

@DriftAccessor(
  tables: [
    Presets,
    PresetSlots,
    PresetParameterValues,
    PresetMappings,
    PresetParameterStringValues,
    Algorithms,
  ],
)
class PresetsDao extends DatabaseAccessor<AppDatabase> with _$PresetsDaoMixin {
  PresetsDao(super.db);

  // --- Query Methods ---

  Stream<List<PresetEntry>> watchAllPresets() => select(presets).watch();

  Future<List<PresetEntry>> getAllPresets() => select(presets).get();

  Future<PresetEntry?> getPresetByName(String name) {
    return (select(
      presets,
    )..where((p) => p.name.equals(name))).getSingleOrNull();
  }

  Future<PresetEntry?> getPresetById(int id) {
    return (select(presets)..where((p) => p.id.equals(id))).getSingleOrNull();
  }

  Future<List<FullPresetDetails>> getTemplates() async {
    final templatePresets = await (select(presets)
          ..where((p) => p.isTemplate.equals(true))
          ..orderBy([(p) => OrderingTerm.asc(p.name)]))
        .get();
    final List<FullPresetDetails> templates = [];
    for (final preset in templatePresets) {
      final details = await getFullPresetDetails(preset.id);
      if (details != null) {
        templates.add(details);
      }
    }
    return templates;
  }

  Stream<int> watchTemplateCount() {
    final query = selectOnly(presets)
      ..addColumns([presets.id.count()])
      ..where(presets.isTemplate.equals(true));
    return query.map((row) => row.read(presets.id.count()) ?? 0).watchSingle();
  }

  Future<List<FullPresetDetails>> getNonTemplates() async {
    final nonTemplatePresets =
        await (select(presets)..where((p) => p.isTemplate.equals(false))).get();
    final List<FullPresetDetails> nonTemplates = [];
    for (final preset in nonTemplatePresets) {
      final details = await getFullPresetDetails(preset.id);
      if (details != null) {
        nonTemplates.add(details);
      }
    }
    return nonTemplates;
  }

  Future<FullPresetDetails?> getFullPresetDetails(int presetId) async {
    final presetEntry = await (select(
      presets,
    )..where((p) => p.id.equals(presetId))).getSingleOrNull();

    if (presetEntry == null) return null;

    try {
      // Fetch all slots for the preset
      final slotEntries = await (select(
        presetSlots,
      )..where((s) => s.presetId.equals(presetId))).get();

      if (slotEntries.isEmpty) {
        return FullPresetDetails(preset: presetEntry, slots: []);
      }

      final slotIds = slotEntries.map((s) => s.id).toList();
      final algorithmGuids = slotEntries
          .map((s) => s.algorithmGuid)
          .toSet(); // Use Set for efficiency

      // Fetch required related data in batches
      final algorithmsQuery = select(algorithms)
        ..where((a) => a.guid.isIn(algorithmGuids));
      final algorithmsMap = {
        for (var a in await algorithmsQuery.get()) a.guid: a,
      };

      // Fetch parameter values
      final valuesQuery = select(presetParameterValues)
        ..where((v) => v.presetSlotId.isIn(slotIds));
      final valueEntries = await valuesQuery.get();
      final paramValuesBySlot =
          groupBy<PresetParameterValueEntry, int>(
            valueEntries,
            (v) => v.presetSlotId,
          ).map(
            (slotId, entries) => MapEntry(slotId, {
              for (var e in entries) e.parameterNumber: e.value,
            }),
          );

      // Fetch parameter string values
      final stringValuesQuery =
          select(presetParameterStringValues) // Use generated reference
            ..where((sv) => sv.presetSlotId.isIn(slotIds));
      final stringValueEntries = await stringValuesQuery.get();
      final paramStringValuesBySlot =
          groupBy<PresetParameterStringValueEntry, int>(
            stringValueEntries,
            (sv) => sv.presetSlotId,
          ).map(
            (slotId, entries) => MapEntry(slotId, {
              for (var e in entries) e.parameterNumber: e.stringValue,
            }),
          );

      // Fetch mappings
      final mappingsQuery = select(presetMappings)
        ..where((m) => m.presetSlotId.isIn(slotIds));
      final mappingEntries = await mappingsQuery.get();
      final paramMappingsBySlot =
          groupBy<PresetMappingEntry, int>(
            mappingEntries,
            (m) => m.presetSlotId,
          ).map(
            (slotId, entries) => MapEntry(slotId, {
              for (var e in entries) e.parameterNumber: e.packedData,
            }),
          );

      // Assemble FullPresetSlot list
      final List<FullPresetSlot> fullSlots = [];
      for (final slotEntry in slotEntries) {
        final algorithm = algorithmsMap[slotEntry.algorithmGuid];
        if (algorithm != null) {
          final slotId = slotEntry.id;
          fullSlots.add(
            FullPresetSlot(
              slot: slotEntry,
              algorithm: algorithm,
              parameterValues: paramValuesBySlot[slotId] ?? {},
              parameterStringValues: paramStringValuesBySlot[slotId] ?? {},
              mappings: paramMappingsBySlot[slotId] ?? {},
            ),
          );
        } else {
          // Handle missing algorithm metadata gracefully (e.g., skip slot or error)
        }
      }

      // Sort slots by slotIndex using standard sort
      fullSlots.sort((a, b) => a.slot.slotIndex.compareTo(b.slot.slotIndex));

      return FullPresetDetails(preset: presetEntry, slots: fullSlots);
    } catch (e) {
      return null;
    }
  }

  // --- Insertion/Update Methods ---

  /// Saves a complete preset structure (insert or update).
  /// Handles saving the preset entry, slots, values, mappings, routing, and string values.
  /// Returns the ID of the saved/updated preset.
  Future<int> saveFullPreset(
    FullPresetDetails details, {
    bool isTemplate = false,
  }) async {
    return transaction(() async {
      // 1. Upsert Preset Entry
      final presetCompanion = details.preset
          .toCompanion(true) // Convert PresetEntry to its companion
          // Explicitly handle the ID: if it's -1, treat it as absent for auto-increment.
          // Otherwise, use the provided ID for potential replacement.
          .copyWith(
            id: details.preset.id == -1
                ? const Value.absent()
                : Value(details.preset.id),
            lastModified: Value(DateTime.now()),
            isTemplate: Value(isTemplate),
          );

      // Insert the companion. `insertOrReplace` will:
      // - Insert if `id` is absent (and generate a new ID).
      // - Replace if `id` is present and matches an existing row.
      final presetId = await into(presets).insert(
        presetCompanion,
        mode:
            InsertMode.insertOrReplace, // Handles insert or update based on ID
      );

      // --- Check if insert returned a valid ID ---
      // SQLite rowid starts at 1. If we get 0 or less, something went wrong.
      if (presetId <= 0) {
        // Throw an exception if the insert/replace failed to return a valid ID.
        // This should cause the transaction to roll back.
        throw Exception(
          "Database operation failed: Invalid preset ID returned ($presetId)",
        );
      }
      // --- End Check ---

      // 2. Handle Slots
      final existingSlots = await (select(
        presetSlots,
      )..where((s) => s.presetId.equals(presetId))).get();
      final Map<int, PresetSlotEntry> existingSlotsById = {
        for (var s in existingSlots) s.id: s,
      };
      final Set<int> incomingSlotIds = {};

      for (final fullSlot in details.slots) {
        PresetSlotEntry? existingSlotForIndex;
        for (var es in existingSlotsById.values) {
          if (es.slotIndex == fullSlot.slot.slotIndex) {
            existingSlotForIndex = es;
            break;
          }
        }

        // Upsert slot entry using companion constructor
        final slotCompanion = PresetSlotsCompanion(
          presetId: Value(presetId),
          slotIndex: Value(fullSlot.slot.slotIndex),
          algorithmGuid: Value(fullSlot.slot.algorithmGuid),
          customName: Value(fullSlot.slot.customName),
          id: existingSlotForIndex != null
              ? Value(existingSlotForIndex.id)
              : const Value.absent(),
        );
        final slotId = await into(
          presetSlots,
        ).insert(slotCompanion, mode: InsertMode.insertOrReplace);
        incomingSlotIds.add(slotId);

        // Clear existing related data for this slot
        await batch((batch) {
          batch.deleteWhere(
            presetParameterValues,
            (row) => row.presetSlotId.equals(slotId),
          );
          batch.deleteWhere(
            presetParameterStringValues,
            (row) => row.presetSlotId.equals(slotId),
          );
          batch.deleteWhere(
            presetMappings,
            (row) => row.presetSlotId.equals(slotId),
          );
        });

        // Batch insert new data using .insert() companions
        await batch((batch) {
          if (fullSlot.parameterValues.isNotEmpty) {
            batch.insertAll(
              presetParameterValues,
              fullSlot.parameterValues.entries
                  .map(
                    (e) => PresetParameterValuesCompanion.insert(
                      presetSlotId: slotId,
                      parameterNumber: e.key,
                      value: e.value,
                    ),
                  )
                  .toList(),
            );
          }
          if (fullSlot.parameterStringValues.isNotEmpty) {
            batch.insertAll(
              presetParameterStringValues,
              fullSlot.parameterStringValues.entries
                  .map(
                    (e) => PresetParameterStringValuesCompanion.insert(
                      presetSlotId: slotId,
                      parameterNumber: e.key,
                      stringValue: e.value,
                    ),
                  )
                  .toList(),
            );
          }
          if (fullSlot.mappings.isNotEmpty) {
            batch.insertAll(
              presetMappings,
              fullSlot.mappings.entries
                  .map(
                    (e) => PresetMappingsCompanion.insert(
                      presetSlotId: slotId,
                      parameterNumber: e.key,
                      packedData: e.value,
                      perfPageIndex: Value(e.value.perfPageIndex),
                    ),
                  )
                  .toList(),
            );
          }
        });
      }

      // 4. Delete slots (and their cascaded data) that were in the DB but not in the incoming details
      final Set<int> existingSlotIdsSet = existingSlotsById.keys.toSet();
      final slotsToDelete = existingSlotIdsSet.difference(incomingSlotIds);
      if (slotsToDelete.isNotEmpty) {
        await (delete(
          presetSlots,
        )..where((s) => s.id.isIn(slotsToDelete))).go();
      }

      return presetId;
    });
  }

  Future<void> updatePresetName(int presetId, String newName) async {
    await (update(presets)..where((p) => p.id.equals(presetId))).write(
      PresetsCompanion(
        name: Value(newName),
        lastModified: Value(DateTime.now()),
      ),
    );
  }

  Future<void> toggleTemplateStatus(int presetId, bool newStatus) async {
    await (update(presets)..where((p) => p.id.equals(presetId))).write(
      PresetsCompanion(
        isTemplate: Value(newStatus),
        lastModified: Value(DateTime.now()),
      ),
    );
  }

  /// Updates the performance page index for a specific parameter in a preset slot.
  ///
  /// - [presetSlotId]: The ID of the preset slot (from PresetSlots table)
  /// - [parameterNumber]: The parameter number within the algorithm
  /// - [perfPageIndex]: The performance page index (0-15, where 0 = not assigned)
  Future<void> updatePerformancePageIndex({
    required int presetSlotId,
    required int parameterNumber,
    required int perfPageIndex,
  }) async {
    // Update the perfPageIndex column in the presetMappings table
    await (update(presetMappings)
          ..where((m) => m.presetSlotId.equals(presetSlotId))
          ..where((m) => m.parameterNumber.equals(parameterNumber)))
        .write(PresetMappingsCompanion(perfPageIndex: Value(perfPageIndex)));
  }

  // --- Deletion Methods ---

  Future<void> deletePreset(int presetId) async {
    await (delete(presets)..where((p) => p.id.equals(presetId))).go();
    // Note: Cascading deletes in the table definitions should handle related data
    // (PresetSlots -> PresetParameterValues, PresetParameterStringValues, PresetMappings, PresetRoutings)
  }
}
