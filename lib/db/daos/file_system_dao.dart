import 'package:drift/drift.dart';
import 'package:nt_helper/db/database.dart';
import 'package:nt_helper/db/tables.dart';

part 'file_system_dao.g.dart'; // Generated by build_runner

@DriftAccessor(tables: [FileSystemEntries])
class FileSystemDao extends DatabaseAccessor<AppDatabase>
    with _$FileSystemDaoMixin {
  FileSystemDao(AppDatabase db) : super(db);

  // --- Query Methods ---

  // Get direct children of a directory ID
  Stream<List<FileSystemEntry>> watchChildrenOf(int? parentId) {
    final query = select(fileSystemEntries)
      ..where((f) =>
          parentId == null ? f.parentId.isNull() : f.parentId.equals(parentId))
      ..orderBy([
        // Combine ordering terms into a single list
        (f) => OrderingTerm.asc(f.isDirectory), // Dirs first
        (f) => OrderingTerm.asc(f.name) // Then by name
      ]);
    return query.watch();
  }

  // Get root entries (parentId is null)
  Stream<List<FileSystemEntry>> watchRootEntries() => watchChildrenOf(null);

  // Get a specific entry by its unique full path
  Future<FileSystemEntry?> getEntryByPath(String fullPath) {
    return (select(fileSystemEntries)
          ..where((f) => f.fullPath.equals(fullPath)))
        .getSingleOrNull();
  }

  // Find entries by name (simple substring search)
  Future<List<FileSystemEntry>> searchEntriesByName(String nameQuery) {
    if (nameQuery.isEmpty) return Future.value([]);
    return (select(fileSystemEntries)..where((f) => f.name.contains(nameQuery)))
        .get();
  }

  // --- Insertion/Update Methods ---

  // Upsert a single entry. Returns the ID.
  Future<int> upsertEntry(FileSystemEntriesCompanion entry) {
    return into(fileSystemEntries)
        .insert(entry, mode: InsertMode.insertOrReplace);
  }

  // Batch upsert entries
  Future<void> upsertEntries(List<FileSystemEntriesCompanion> entries) {
    return batch((batch) {
      batch.insertAll(fileSystemEntries, entries,
          mode: InsertMode.insertOrReplace);
    });
  }

  // Replaces all entries under a given parent path.
  // Useful for refreshing a directory's contents.
  Future<void> replaceEntriesUnderPath(
      String parentPath, List<FileSystemEntriesCompanion> newEntries) async {
    return transaction(() async {
      // Find the parent ID (if it exists)
      final parentEntry = await getEntryByPath(parentPath);
      final parentId = parentEntry?.id;

      // Delete all existing children recursively under this path
      await deleteEntriesUnderPath(parentPath, keepParent: true);

      // Insert the new entries
      // Ensure parentId is set correctly in the companions before calling this
      await upsertEntries(newEntries
          .map((e) => e.copyWith(parentId: Value(parentId)))
          .toList());
    });
  }

  // --- Deletion Methods ---

  // Delete a single entry by ID
  Future<int> deleteEntry(int id) {
    // Be careful: this doesn't automatically delete children
    return (delete(fileSystemEntries)..where((f) => f.id.equals(id))).go();
  }

  // Delete an entry by path (does not delete children by default)
  Future<int> deleteEntryByPath(String fullPath) {
    return (delete(fileSystemEntries)
          ..where((f) => f.fullPath.equals(fullPath)))
        .go();
  }

  // Deletes an entry and all its descendants recursively.
  Future<void> deleteEntriesUnderPath(String pathToDelete,
      {bool keepParent = false}) async {
    return transaction(() async {
      final entryToDelete = await getEntryByPath(pathToDelete);
      if (entryToDelete == null) return; // Path doesn't exist

      // Find all descendants (children, grandchildren, etc.)
      final List<int> idsToDelete = [];
      final List<int> queue = [entryToDelete.id];

      while (queue.isNotEmpty) {
        final currentId = queue.removeAt(0);
        if (!keepParent || currentId != entryToDelete.id) {
          idsToDelete.add(currentId);
        }

        final children = await (select(fileSystemEntries)
              ..where((f) => f.parentId.equals(currentId)))
            .get();
        queue.addAll(children.map((c) => c.id));
      }

      if (idsToDelete.isNotEmpty) {
        await (delete(fileSystemEntries)..where((f) => f.id.isIn(idsToDelete)))
            .go();
      }
    });
  }

  // Clear the entire file system representation
  Future<int> clearAllFileSystemEntries() {
    return delete(fileSystemEntries).go();
  }
}
