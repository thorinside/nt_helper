// lib/db/database.dart
import 'dart:io';

import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:nt_helper/db/daos/metadata_dao.dart';
import 'package:nt_helper/db/daos/presets_dao.dart';
import 'package:nt_helper/db/daos/plugin_installations_dao.dart';
import 'package:nt_helper/db/tables.dart';
import 'package:nt_helper/models/packed_mapping_data.dart'; // Import for converter
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';
part 'database.g.dart'; // Generated by build_runner

@DriftDatabase(
  tables: [
    // Core Metadata
    Algorithms,
    Specifications,
    Units,
    Parameters,
    ParameterEnums,
    ParameterPages,
    ParameterPageItems,
    ParameterOutputModeUsage,
    // Preset Data
    Presets,
    PresetSlots,
    PresetParameterValues,
    PresetParameterStringValues,
    PresetMappings,
    PresetRoutings,
    // General Cache
    MetadataCache,
    // Plugin Installation Tracking
    PluginInstallations,
  ],
  daos: [MetadataDao, PresetsDao, PluginInstallationsDao],
)
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(_openConnection());

  // Test constructor for in-memory database
  AppDatabase.forTesting(super.executor);

  @override
  int get schemaVersion => 10; // Incremented for ioFlags column in Parameters table

  // Access DAOs (Drift generates getters)
  // MetadataDao get metadataDao => MetadataDao(this); // This getter is generated
  // PresetsDao get presetsDao => PresetsDao(this); // This getter is generated
  // FileSystemDao get fileSystemDao => FileSystemDao(this); // This getter is generated

  // --- MIGRATION LOGIC ---
  @override
  MigrationStrategy get migration => MigrationStrategy(
    onCreate: (Migrator m) async {
      await m.createAll();
      // Add initial data if needed
    },
    onUpgrade: (Migrator m, int from, int to) async {
      // Example: Migrating FROM version 1 TO version 2 (or higher)
      if (from == 1) {
        try {
          await m.addColumn(parameters, parameters.rawUnitIndex);
        } catch (e) {
          // Consider re-throwing or handling the error appropriately
        }
      }

      // Migration for version 3: Add SdCards and IndexedPresetFiles tables (removed in version 7)
      if (from <= 2) {
        try {} catch (e) {
          // Intentionally empty
        }
      }

      // Migration for version 4: Add PluginInstallations table
      if (from <= 3) {
        try {
          await m.createTable(pluginInstallations);
        } catch (e) {
          // Intentionally empty
        }
      }

      // Migration for version 5: Add pluginFilePath column to algorithms table
      if (from <= 4) {
        try {
          await m.addColumn(algorithms, algorithms.pluginFilePath);
        } catch (e) {
          // Intentionally empty
        }
      }

      // Migration for version 6: Add version tracking columns to plugin_installations table
      if (from <= 5) {
        try {
          await m.addColumn(
            pluginInstallations,
            pluginInstallations.availableVersion,
          );
          await m.addColumn(
            pluginInstallations,
            pluginInstallations.updateAvailable,
          );
          await m.addColumn(
            pluginInstallations,
            pluginInstallations.lastChecked,
          );
        } catch (e) {
          // Intentionally empty
        }
      }

      // Migration for version 7: Remove obsolete SD card scanning tables
      if (from <= 6) {
        try {
          // Drop tables if they exist (safe for fresh installs)
          await m.database.customStatement(
            'DROP TABLE IF EXISTS indexed_preset_files',
          );
          await m.database.customStatement('DROP TABLE IF EXISTS sd_cards');
        } catch (e) {
          // Non-critical error - tables might not exist in some installations
        }
      }

      // Migration for version 8: Add perfPageIndex column to preset_mappings table
      if (from <= 7) {
        try {
          await m.addColumn(presetMappings, presetMappings.perfPageIndex);
        } catch (e) {
          // Intentionally empty
        }
      }

      // Migration for version 9: Add isTemplate column to presets table
      if (from <= 8) {
        try {
          await m.addColumn(presets, presets.isTemplate);
        } catch (e) {
          // Intentionally empty
        }
      }

      // Migration for version 10: Add ioFlags column to parameters table and create ParameterOutputModeUsage table
      // This column stores I/O metadata flags from firmware (bits 2-5 of last byte)
      // null = no data available, 0-15 = flag combinations
      // ParameterOutputModeUsage table stores which output numbers are affected by output mode parameters
      if (from <= 9) {
        try {
          await m.addColumn(parameters, parameters.ioFlags);
        } catch (e) {
          // Intentionally empty - column may already exist in some edge cases
        }
        try {
          await m.createTable(parameterOutputModeUsage);
        } catch (e) {
          // Intentionally empty - table may already exist in some edge cases
        }
      }
    },
  );

  // Define DAO getters
  // MetadataDao get metadataDao => attachedDatabase.accessor(MetadataDao(this));
  // ... other DAO getters ...
}

LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'nt_helper_db.sqlite'));
    // Consider adding logStatements: true during development for debugging
    return NativeDatabase.createInBackground(file /*, logStatements: true*/);
  });
}
