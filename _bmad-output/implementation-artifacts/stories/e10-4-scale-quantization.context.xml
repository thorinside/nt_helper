<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>10</epicId>
    <storyId>4</storyId>
    <title>Scale Quantization</title>
    <status>drafted</status>
    <generatedAt>2025-11-23</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/e10-4-scale-quantization.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>user</asA>
    <iWant>to snap pitch values to a musical scale</iWant>
    <soThat>my sequences are always in-key</soThat>
    <tasks>
      - Create ScaleQuantizer service with scale intervals map and quantize() method
      - Create QuantizeControls widget with toggle, scale selector, root note selector, and bulk quantize button
      - Integrate quantization into StepEditModal to apply real-time quantization
      - Add quantize state to StepSequencerView (snapEnabled, selectedScale, rootNote)
      - Implement "Quantize All Steps" bulk operation with progress indicator and confirmation
      - Add comprehensive unit, widget, and integration tests
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC4.1">"Snap to Scale" toggle button in header (ON/OFF states)</criterion>
    <criterion id="AC4.2">Scale selector dropdown (Chromatic, Major, Minor, Dorian, Pentatonic, etc.)</criterion>
    <criterion id="AC4.3">Root note selector (C, C#, D, ... B)</criterion>
    <criterion id="AC4.4">When snap enabled: pitch edits quantize to nearest scale degree in real-time</criterion>
    <criterion id="AC4.5">"Quantize All Steps" button applies current scale to all existing steps (with confirmation)</criterion>
    <criterion id="AC4.6">Toggle OFF â†’ raw MIDI values (no quantization)</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/epics/epic-step-sequencer-ui.md</path>
        <title>Epic: Visual Step Sequencer UI Widget</title>
        <section>Story 4: Scale Quantization</section>
        <snippet>Transform pitch values by snapping to musical scales. Provides ScaleQuantizer class with 11 scales (Chromatic, Major, Minor, Dorian, Phrygian, Lydian, Mixolydian, Aeolian, Locrian, Pentatonic Major/Minor) and quantize() method with root note transposition. UI-only feature, not persisted to hardware.</snippet>
      </doc>
      <doc>
        <path>docs/epics/epic-step-sequencer-ui-technical-context.md</path>
        <title>Technical Context: Step Sequencer UI Epic</title>
        <section>Technical Decisions - Scale Quantization (UI-Only)</section>
        <snippet>Quantization happens in UI layer, not persisted to hardware. Hardware stores raw MIDI note values. Quantization is a composition aid. Aligns with DAW workflow where MIDI notes are raw and quantization is non-destructive. Uses modulo arithmetic to find nearest scale degree.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>nt_helper Brownfield Architecture Document</title>
        <section>Coding Standards and Patterns - State Management Patterns</section>
        <snippet>Use Cubit pattern with flutter_bloc. States defined with freezed. Local StatefulWidget state for transient UI concerns. DistingCubit manages all parameter values. Avoid bloating DistingCubit with algorithm-specific logic.</snippet>
      </doc>
      <doc>
        <path>docs/stories/e10-3-step-selection-and-editing.md</path>
        <title>Story: Step Selection and Editing</title>
        <section>Learnings from Previous Story</section>
        <snippet>Parameter updates use 50ms debouncing via ParameterWriteDebouncer. Local state updates immediately for smooth UI feedback. All changes delegate to DistingCubit.updateParameterValue(). Responsive modal pattern established. Copy/paste stores parameters in local state map (not persistent).</snippet>
      </doc>
    </docs>

    <code>
      <file>
        <path>lib/services/step_sequencer_params.dart</path>
        <kind>service</kind>
        <symbol>StepSequencerParams</symbol>
        <lines>all</lines>
        <reason>Parameter discovery service - provides getPitch(step) helper to resolve parameter numbers for bulk quantization operations. Already implemented in Story 1.</reason>
      </file>
      <file>
        <path>lib/ui/step_sequencer_view.dart</path>
        <kind>widget</kind>
        <symbol>StepSequencerView</symbol>
        <lines>all</lines>
        <reason>Main widget for Step Sequencer - will be modified to add local state for snapEnabled, selectedScale, rootNote and pass to QuantizeControls and StepEditModal.</reason>
      </file>
      <file>
        <path>lib/ui/widgets/step_sequencer/step_edit_modal.dart</path>
        <kind>widget</kind>
        <symbol>StepEditModal</symbol>
        <lines>all</lines>
        <reason>Step editing modal - will be modified to apply quantization to pitch slider changes when snap enabled. Needs to read snap state from parent and call ScaleQuantizer.quantize().</reason>
      </file>
      <file>
        <path>lib/ui/widgets/step_sequencer/step_grid_view.dart</path>
        <kind>widget</kind>
        <symbol>StepGridView</symbol>
        <lines>all</lines>
        <reason>Grid display component - may need visual indication when quantize is active. Reference for responsive layout patterns.</reason>
      </file>
      <file>
        <path>lib/ui/widgets/step_sequencer/step_column_widget.dart</path>
        <kind>widget</kind>
        <symbol>StepColumnWidget</symbol>
        <lines>all</lines>
        <reason>Individual step column - reference for tap handling pattern. May need visual indication of quantized values.</reason>
      </file>
      <file>
        <path>lib/cubit/disting_cubit.dart</path>
        <kind>cubit</kind>
        <symbol>DistingCubit.updateParameterValue</symbol>
        <lines>search for "updateParameterValue"</lines>
        <reason>Core state management - all parameter updates must go through this method. Will be called for bulk quantization of all steps.</reason>
      </file>
      <file>
        <path>lib/cubit/disting_state.dart</path>
        <kind>state</kind>
        <symbol>Slot</symbol>
        <lines>search for "class Slot"</lines>
        <reason>Slot data model - contains parameterValues list needed to read current pitch values for bulk quantization.</reason>
      </file>
    </code>

    <dependencies>
      <flutter>
        <package name="flutter_bloc" version="^9.1.1">State management - BlocBuilder for reactive UI updates</package>
        <package name="cupertino_icons" version="^1.0.8">Icons for toggle button (Icons.piano)</package>
      </flutter>
    </dependencies>
  </artifacts>

  <constraints>
    - Quantization is UI-only (not persisted to hardware) - hardware stores raw MIDI note values
    - Use local StatefulWidget state for quantize settings (not DistingCubit)
    - All parameter updates must go through DistingCubit.updateParameterValue()
    - Follow responsive design patterns from existing step sequencer widgets (mobile vs desktop)
    - Use theme colors for consistency (primaryTeal for active states)
    - Bulk quantization must use debouncing to avoid overwhelming MIDI scheduler
    - Confirmation dialog required for destructive "Quantize All Steps" operation
    - flutter analyze must pass with zero warnings
    - Dark mode support required
  </constraints>

  <interfaces>
    <interface>
      <name>DistingCubit.updateParameterValue</name>
      <kind>method</kind>
      <signature>void updateParameterValue(int slotIndex, int paramNumber, dynamic value)</signature>
      <path>lib/cubit/disting_cubit.dart</path>
      <usage>Call this method for all parameter updates (individual pitch changes and bulk quantization). Will trigger MIDI write and update slot state.</usage>
    </interface>
    <interface>
      <name>StepSequencerParams.getPitch</name>
      <kind>method</kind>
      <signature>int? getPitch(int step)</signature>
      <path>lib/services/step_sequencer_params.dart</path>
      <usage>Resolves parameter number for a given step's pitch parameter (step is 1-indexed). Returns null if parameter not found. Use for bulk quantization loop.</usage>
    </interface>
    <interface>
      <name>Slot.parameterValues</name>
      <kind>property</kind>
      <signature>List&lt;int&gt; parameterValues</signature>
      <path>lib/cubit/disting_state.dart</path>
      <usage>Read-only list of current parameter values indexed by parameter number. Use to read current pitch values before quantizing.</usage>
    </interface>
    <interface>
      <name>ScaleQuantizer.quantize (NEW)</name>
      <kind>static method</kind>
      <signature>static int quantize(int midiNote, String scale, int root)</signature>
      <path>lib/services/scale_quantizer.dart</path>
      <usage>Quantizes a MIDI note (0-127) to nearest scale degree. Returns quantized MIDI note. Scale is key from scales map, root is 0-11 (C-B). Pure function, no side effects.</usage>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Use flutter_test for unit and widget tests. Follow existing patterns from test/ui/widgets/step_sequencer/. Use blocTest for any cubit interactions (though this story uses local state). Widget tests should verify UI rendering and user interactions. Integration tests verify full workflow from toggle to parameter update.
    </standards>
    <locations>
      - test/services/scale_quantizer_test.dart (NEW - unit tests for quantization logic)
      - test/ui/widgets/step_sequencer/quantize_controls_test.dart (NEW - widget tests)
      - test/ui/widgets/step_sequencer/step_sequencer_integration_test.dart (extend existing for quantize workflow)
    </locations>
    <ideas>
      - AC4.1: Widget test for toggle button state changes (ON/OFF visual feedback)
      - AC4.2: Widget test for scale dropdown with all 11 scale options present
      - AC4.3: Widget test for root note selector (C-B with sharps/flats)
      - AC4.4: Unit test for real-time quantization (all scales, all roots, edge cases like note 0 and 127)
      - AC4.4: Integration test for pitch slider + quantize = quantized value written to cubit
      - AC4.5: Integration test for "Quantize All Steps" button with confirmation dialog
      - AC4.5: Unit test for bulk quantization loop (all 16 steps)
      - AC4.6: Integration test for toggle OFF behavior (raw MIDI values preserved)
      - Unit test: Scale intervals map accuracy (verify all 11 scales have correct intervals)
      - Unit test: Modulo arithmetic edge cases (octave boundaries, chromatic scale passthrough)
      - Unit test: Root note transposition (all 12 roots, verify wrapping at octave boundary)
    </ideas>
  </tests>
</story-context>
