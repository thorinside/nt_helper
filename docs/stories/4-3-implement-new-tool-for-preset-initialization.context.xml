<story-context id="bmad/bmm/workflows/4-implementation/story-context" v="1.0">
  <metadata>
    <epicId>4</epicId>
    <storyId>3</storyId>
    <title>Implement new tool for preset initialization</title>
    <status>drafted</status>
    <generatedAt>2025-11-07</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/4-3-implement-new-tool-for-preset-initialization.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>LLM client starting preset creation</asA>
    <iWant>a tool that creates a new blank preset or preset with initial algorithms</iWant>
    <soThat>I have a clean starting point for building my configuration</soThat>
    <tasks>
      <task>Define new tool schema (AC: 1, 13) with name/algorithms parameters, warning about clearing current preset, and JSON schema examples</task>
      <task>Implement algorithm validation (AC: 4, 6-7) with GUID lookup, fuzzy name matching, and specification validation</task>
      <task>Implement preset initialization logic (AC: 2, 8-10) to clear preset, set name, add algorithms sequentially, ensure default values</task>
      <task>Implement state return (AC: 11) with slot details, parameter values, and disabled mapping state</task>
      <task>Implement mode validation (AC: 12) rejecting offline/demo modes</task>
      <task>Register tool and test (AC: 14-15) with unit/integration tests and flutter analyze/test passes</task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="1">Create `new` tool accepting: `name` (string, required), `algorithms` (array, optional)</criterion>
    <criterion id="2">When `algorithms` not provided, create blank preset with specified name</criterion>
    <criterion id="3">When `algorithms` provided, accept array of: `{ "guid": "...", "name": "...", "specifications": [...] }`</criterion>
    <criterion id="4">Support algorithm identification by GUID or name (fuzzy matching ≥70%)</criterion>
    <criterion id="5">`specifications` array provides values for algorithm creation (required for some algorithms, optional for others)</criterion>
    <criterion id="6">Tool validates algorithm existence before creation</criterion>
    <criterion id="7">Tool validates specification values against algorithm requirements</criterion>
    <criterion id="8">Tool clears current preset on device (unsaved changes lost - warn in description)</criterion>
    <criterion id="9">Tool adds algorithms sequentially to slots 0, 1, 2, etc.</criterion>
    <criterion id="10">New algorithms have default parameter values and all mappings disabled (CV/MIDI/i2c enabled=false, performance_page=0)</criterion>
    <criterion id="11">Return created preset state with all slots, default parameter values, and disabled mappings</criterion>
    <criterion id="12">Tool fails with clear error if in offline/demo mode</criterion>
    <criterion id="13">JSON schema includes examples: blank preset, preset with 1 algorithm, preset with 3 algorithms</criterion>
    <criterion id="14">`flutter analyze` passes with zero warnings</criterion>
    <criterion id="15">All tests pass</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/epic-4-context.md</path>
        <title>Epic 4: MCP Library Replacement & Simplified Preset Creation API - Technical Context</title>
        <section>New API Design - section 2: new</section>
        <snippet>The 'new' tool creates a blank preset or one with initial algorithms. Input: name (required), algorithms (optional array with guid/name/specifications). Returns created preset state with all slots and default values.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>nt_helper Brownfield Architecture Document</title>
        <section>Critical Files for Understanding the System - State Management, MCP Server, SysEx Request Implementations</section>
        <snippet>DistingCubit manages all device state via IDistingMidiManager hierarchy. Exposes synchronized Slot objects with algorithms, parameters, and values. SysEx requests in lib/domain/sysex/requests/ implement individual command types. MCP Server at lib/services/mcp_server_service.dart handles HTTP-based tool registration and multi-client support.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>nt_helper - Epic Breakdown</title>
        <section>Epic 4: MCP Library Replacement & Simplified Preset Creation API</section>
        <snippet>Epic 4 replaces the current MCP implementation with dart_mcp library and redesigns the MCP tool interface around four intuitive operations: search, new, edit, and show. Four core tools with flexible granularity reduce cognitive load and enable smaller models to succeed.</snippet>
      </doc>
      <doc>
        <path>docs/stories/4-2-implement-search-tool-for-algorithm-discovery.md</path>
        <title>Story 4.2: Implement search tool for algorithm discovery</title>
        <section>Fuzzy Matching Implementation</section>
        <snippet>Story 4.2 provides fuzzy string matching algorithm with ≥70% similarity threshold. This matching logic should be reused in Story 4.3 for algorithm name matching when guid not provided. Consider using existing Dart packages for fuzzy string matching or Levenshtein distance algorithm.</snippet>
      </doc>
    </docs>

    <code>
      <artifact>
        <path>lib/cubit/disting_cubit.dart</path>
        <kind>state-management</kind>
        <symbol>DistingCubit.requestNewPreset(), DistingCubit.requestSavePreset()</symbol>
        <reason>Central state management cubit that handles requestNewPreset() to clear current preset. Query this cubit to get current connection state (must be Synchronized state). Access via _distingCubit in MCP tool handlers.</reason>
      </artifact>
      <artifact>
        <path>lib/services/disting_controller.dart</path>
        <kind>interface</kind>
        <symbol>DistingController</symbol>
        <reason>Abstract interface defining operations to control Disting state. Key methods: setPresetName(), addAlgorithm(), getAllSlots(), getParametersForSlot(), updateParameterValue(). Use this interface for all preset/slot/parameter operations in the new tool.</reason>
      </artifact>
      <artifact>
        <path>lib/services/disting_controller_impl.dart</path>
        <kind>implementation</kind>
        <symbol>DistingControllerImpl</symbol>
        <lines>1-50</lines>
        <reason>Implementation of DistingController interface. Provides concrete methods for preset management, algorithm operations, and parameter control. Created from _distingCubit, accessible to MCP tool handlers.</reason>
      </artifact>
      <artifact>
        <path>lib/services/algorithm_metadata_service.dart</path>
        <kind>service</kind>
        <symbol>AlgorithmMetadataService.getAlgorithmByGuid(), findAlgorithmsByQuery(), getExpandedParameters()</symbol>
        <reason>Singleton service for algorithm metadata access. Use getAlgorithmByGuid() for GUID lookup, findAlgorithmsByQuery() for fuzzy name matching. getExpandedParameters() returns all parameters including inherited from features.</reason>
      </artifact>
      <artifact>
        <path>lib/domain/disting_nt_sysex.dart</path>
        <kind>data-model</kind>
        <symbol>Algorithm, Slot, ParameterInfo</symbol>
        <reason>Domain models for Algorithm, Slot, and ParameterInfo representing the Disting NT hardware state. Algorithm includes guid, name, and plugin type. ParameterInfo includes default values and constraints. Used for validation and state return.</reason>
      </artifact>
      <artifact>
        <path>lib/models/packed_mapping_data.dart</path>
        <kind>data-model</kind>
        <symbol>PackedMappingData</symbol>
        <reason>Represents the packed binary format for parameter mappings (CV, MIDI, i2c, performance pages). Default state should have all mappings disabled (enabled=false, performance_page=0). Used for initializing new algorithm mappings.</reason>
      </artifact>
      <artifact>
        <path>lib/mcp/tools/disting_tools.dart</path>
        <kind>mcp-tools</kind>
        <symbol>DistingTools class</symbol>
        <lines>1-50</lines>
        <reason>Existing MCP tool implementations for device control. Pattern for tool methods: receive map params, validate state (Synchronized), call DistingController methods, format and return JSON response. Follow this pattern for the new tool.</reason>
      </artifact>
      <artifact>
        <path>lib/mcp/tools/algorithm_tools.dart</path>
        <kind>mcp-tools</kind>
        <symbol>AlgorithmTools class</symbol>
        <reason>Existing MCP tool implementations for algorithm operations. May contain or reference fuzzy matching logic reused from Story 4.2. Check for searchAlgorithms() method that implements fuzzy matching ≥70% similarity.</reason>
      </artifact>
      <artifact>
        <path>lib/services/mcp_server_service.dart</path>
        <kind>service</kind>
        <symbol>McpServerService class, tool registration</symbol>
        <lines>100-200</lines>
        <reason>MCP server service where tools are registered. Find the section registering tools (search, other operations) and add the new tool handler following the same pattern. HTTP server on port 3000 with /mcp endpoint.</reason>
      </artifact>
      <artifact>
        <path>lib/cubit/disting_state.dart</path>
        <kind>state-model</kind>
        <symbol>SynchronizedState, SelectDeviceState, OfflineState</symbol>
        <reason>State variants representing connection modes. Tool must reject OfflineState and SelectDeviceState (not connected/demo modes). Only allow SynchronizedState. Check state before executing tool logic.</reason>
      </artifact>
    </code>

    <dependencies>
      <flutter>
        <package name="flutter_bloc" version="^9.1.1">State management via Cubit pattern</package>
        <package name="mcp_dart" version="git">Current MCP implementation (to be replaced with dart_mcp in future stories)</package>
      </flutter>
      <dart>
        <package name="collection">Collection utilities for algorithm searching and filtering</package>
      </dart>
      <test>
        <package name="flutter_test" version="sdk">Flutter testing framework</package>
        <package name="mocktail" version="^1.0.4">Mocking framework for unit tests</package>
        <package name="bloc_test" version="^10.0.0">Bloc testing utilities for cubit testing</package>
        <package name="test" version="^1.26.2">Core test framework</package>
      </test>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>
      <category>state-requirement</category>
      <description>Tool MUST verify device is in Synchronized state (connected mode). Reject with clear error if in OfflineState or SelectDeviceState (offline/demo modes).</description>
    </constraint>
    <constraint>
      <category>algorithm-validation</category>
      <description>Algorithm identification supports GUID (exact match) or name (fuzzy match ≥70% similarity). Reuse fuzzy matching implementation from Story 4.2. Both identification methods must validate algorithm exists via AlgorithmMetadataService before attempting to add.</description>
    </constraint>
    <constraint>
      <category>specification-handling</category>
      <description>Specifications are optional but may be required for specific algorithms. Validate specifications against algorithm metadata requirements. Some algorithms (e.g., polyphonic) need voice count specifications. Pass specifications to addAlgorithm() method.</description>
    </constraint>
    <constraint>
      <category>mapping-defaults</category>
      <description>All mappings for new algorithms must be disabled by default: CV (enabled=false), MIDI (is_midi_enabled=false), i2c (is_i2c_enabled=false), performance_page=0. Use PackedMappingData with default/disabled state.</description>
    </constraint>
    <constraint>
      <category>parameter-defaults</category>
      <description>New algorithm parameters get their default values from AlgorithmMetadataService. Do not require caller to specify parameter values - hardware provides defaults on addAlgorithm().</description>
    </constraint>
    <constraint>
      <category>slot-assignment</category>
      <description>Algorithms are added sequentially to slots 0, 1, 2, etc. The hardware/DistingController.addAlgorithm() determines the actual slot index. Do not specify slot numbers in the new tool.</description>
    </constraint>
    <constraint>
      <category>code-quality</category>
      <description>flutter analyze must pass with zero warnings. All code must follow existing project patterns (Cubit state management, Freezed immutability, type-safe SysEx requests).</description>
    </constraint>
    <constraint>
      <category>testing</category>
      <description>Write unit tests for validation logic and integration tests for tool handler. Test blank preset creation, single/multi-algorithm creation, validation failures, and mode rejection. All tests must pass.</description>
    </constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>DistingController</name>
      <kind>abstract-interface</kind>
      <signature>
interface DistingController {
  Future&lt;void&gt; setPresetName(String name);
  Future&lt;void&gt; addAlgorithm(Algorithm algorithm);
  Future&lt;Map&lt;int, Algorithm?&gt;&gt; getAllSlots();
  Future&lt;List&lt;ParameterInfo&gt;&gt; getParametersForSlot(int slotIndex);
}
      </signature>
      <path>lib/services/disting_controller.dart</path>
    </interface>
    <interface>
      <name>AlgorithmMetadataService</name>
      <kind>singleton-service</kind>
      <signature>
class AlgorithmMetadataService {
  AlgorithmMetadata? getAlgorithmByGuid(String guid);
  List&lt;AlgorithmMetadata&gt; findAlgorithmsByQuery(String query);
  List&lt;AlgorithmParameter&gt; getExpandedParameters(String algorithmGuid);
}
      </signature>
      <path>lib/services/algorithm_metadata_service.dart</path>
    </interface>
    <interface>
      <name>DistingCubit State</name>
      <kind>cubit-state</kind>
      <signature>
// Check state type before tool execution
if (state is! SynchronizedState) {
  throw StateError('Tool only available in connected mode');
}
final syncState = state as SynchronizedState;
      </signature>
      <path>lib/cubit/disting_cubit.dart</path>
    </interface>
    <interface>
      <name>MCP Tool Handler Pattern</name>
      <kind>function-signature</kind>
      <signature>
Future&lt;String&gt; newTool(Map&lt;String, dynamic&gt; params) async {
  try {
    // 1. Extract and validate parameters
    final String name = params['name'] as String;
    final List&lt;dynamic&gt;? algorithmsArray = params['algorithms'] as List&lt;dynamic&gt;?;

    // 2. Check device state
    final state = _distingCubit.state;
    if (state is! SynchronizedState) {
      throw StateError('Cannot create preset in offline/demo mode');
    }

    // 3. Validate algorithms and get metadata
    // 4. Call DistingController methods
    // 5. Query current state and return formatted JSON

    return jsonEncode({
      'name': ...,
      'slots': [...]
    });
  } catch (e) {
    return jsonEncode({'error': e.toString()});
  }
}
      </signature>
      <path>lib/mcp/tools/disting_tools.dart</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      <para>The project uses flutter_test with mocktail for mocking and bloc_test for Cubit testing. Tests verify behavior rather than implementation details. Unit tests isolate validation logic (algorithm validation, specification validation). Integration tests verify the complete tool flow with mocked DistingCubit. All test files are in test/ directory matching source structure (e.g., test/mcp/tools/ for tool tests).</para>
    </standards>
    <locations>
      <pattern>test/mcp/tools/</pattern>
      <pattern>test/services/</pattern>
      <pattern>test/cubit/</pattern>
    </locations>
    <ideas>
      <idea criteria-id="4,6-7">Unit tests for algorithm validation: test GUID lookup success/failure, fuzzy matching at different similarity levels (exact, high similarity, low similarity), invalid algorithm error handling</idea>
      <idea criteria-id="5,7">Unit tests for specification validation: test valid specifications, missing required specifications, invalid specification values, algorithm-specific requirements</idea>
      <idea criteria-id="2,8-10">Integration test for blank preset creation: clear existing preset, create blank preset with name, verify state returned with empty slots</idea>
      <idea criteria-id="3,9-10">Integration test for preset with algorithms: create preset with 1 algorithm (GUID-based), verify slot assignment (0), verify default parameter values, verify all mappings disabled</idea>
      <idea criteria-id="3,9-10">Integration test for multi-algorithm preset: create preset with 3 algorithms (mix of GUID and fuzzy name matching), verify sequential slot assignment (0,1,2), verify default values for each</idea>
      <idea criteria-id="12">Mode validation tests: reject in offline mode (OfflineState), reject in demo mode (SelectDeviceState), succeed in connected mode (SynchronizedState)</idea>
      <idea criteria-id="11,1">State return test: verify returned JSON includes all slots with algorithms and parameters, verify disabled mapping structure, verify format matches JSON schema examples</idea>
      <idea criteria-id="13">Schema validation test: verify JSON schema includes three examples (blank preset, 1 algorithm, 3 algorithms), verify schema validates example inputs</idea>
    </ideas>
  </tests>
</story-context>
